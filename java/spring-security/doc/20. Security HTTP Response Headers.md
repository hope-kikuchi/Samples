# 20. Security HTTP Response Headers
> This section discusses Spring Security’s support for adding various security headers to the response.

このセクションでは、 Spring Security がサポートするレスポンスへのセキュリティヘッダーについて議論します。

## 20.1 Default Security Headers
> Spring Security allows users to easily inject the default security headers to assist in protecting their application.

Spring Security はアプリケーションの保護を支援するためデフォルトのセキュリティヘッダーを簡単に追加することができるようになっています。

> The default for Spring Security is to include the following headers:

デフォルトで、 Spring Security は次のヘッダーを含めます。

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

> Strict-Transport-Security is only added on HTTPS requests

`Strict-Transport-Security` は HTTPS リクエストのときのみ追加されます。

> For additional details on each of these headers, refer to the corresponding sections:

これら個々のヘッダーについての追加の詳細な情報については該当する章を参照してください。

- [Cache Control](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-cache-control)
- [Content Type Options](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-content-type-options)
- [HTTP Strict Transport Security](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-hsts)
- [X-Frame-Options](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-frame-options)
- [X-XSS-Protection](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-xss-protection)

> While each of these headers are considered best practice, it should be noted that not all clients utilize the headers, so additional testing is encouraged.

これらのヘッダーはベストプラクティスを考慮されていますが、全てのクライアントがヘッダーを利用できるわけではないということに注意すべきです。
そのため、追加のテストが推奨されます。

> You can customize specific headers.
あなたは、特定のヘッダーをカスタマイズすることができます。

> For example, assume that want your HTTP response headers to look like the following:
たとえば、次のような HTTP レスポンスヘッダーが要求されたとします。

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
```

> Specifically, you want all of the default headers with the following customizations:

特にあなたは全てのデフォルトヘッダーに次のようなカスタマイズをしたいと思うでしょう。

> X-Frame-Options to allow any request from same domain

`X-Frame-Options` は同じドメインからの任意のリクエストを許可します。

> HTTP Strict Transport Security (HSTS) will not be addded to the response

HTTP Strict Transport Security はレスポンスには追加されないだろう。

> You can easily do this with the following Java Configuration:

あなたはこれを以下の Java Configuration で簡単に実行できます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers()
				.frameOptions().sameOrigin()
				.httpStrictTransportSecurity().disable();
	}
}
```

> Alternatively, if you are using Spring Security XML Configuration, you can use the following:

もしくは、 XML Configuration を使っているなら、次のようにできます。

```xml
<http>
	<!-- ... -->

	<headers>
		<frame-options policy="SAMEORIGIN" />
		<hsts disable="true"/>
	</headers>
</http>
```

> If you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults.

もしあなたがデフォルトで追加して欲しくなくて明示的に制御したいのであれば、デフォルトを無効にすることができます。

> An example for both Java and XML based configuration is provided below:

たとえば、 Java, XML 両方で次のように提供されます。

> If you are using Spring Security’s Java Configuration the following will only add Cache Control.

もしあなたが Java Configuration を使っているなら、 Cache Control の追加は次のようにするだけです。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		// do not use any default headers unless explicitly listed
		.defaultsDisabled()
		.cacheControl();
}
}
```

> The following XML will only add Cache Control.

以下の XML は Cache Control だけを追加しています。

```xml
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<cache-control/>
	</headers>
</http>
```

> If necessary, you can disable all of the HTTP Security response headers with the following Java Configuration:

もし必要なら、次のような Java Configuration で全てのセキュリティレスポンスヘッダーを無効にできます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers().disable();
}
}
```

> If necessary, you can disable all of the HTTP Security response headers with the following XML configuration below:

もし必要なら、次のような XML Configuration で全てのセキュリティレスポンスヘッダーを無効にできます。

```xml
<http>
	<!-- ... -->

	<headers disabled="true" />
</http>
```

### 20.1.1 Cache Control
> In the past Spring Security required you to provide your own cache control for your web application.

以前の Spring Security はあなたの Web アプリ独自の Cache Control を要求していました。

> This seemed reasonable at the time, but browser caches have evolved to include caches for secure connections as well.

当時、これは合理的だと考えられていました。
しかし、ブラウザのキャッシュはよりセキュアに接続を含むように進化しました。

> This means that a user may view an authenticated page, log out, and then a malicious user can use the browser history to view the cached page.

これが意味するのは、ユーザが認証済みのページを見てログアウトしたあとに、悪意あるユーザがブラウザの履歴からキャッシュされたページを見れるということです

> To help mitigate this Spring Security has added cache control support which will insert the following headers into you response.

これを移行する助けとして、レスポンスに以下のヘッダーを追加する Cache Control のサポートが Spring Security に追加されました。

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
```

> Similarly, you can enable only cache control within Java Configuration with the following:

TODO

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.defaultsDisabled()
		.cacheControl();
}
}
```

> If you actually want to cache specific responses, your application can selectively invoke HttpServletResponse.setHeader(String,String) to override the header set by Spring Security.

> This is useful to ensure things like CSS, JavaScript, and images are properly cached.

> When using Spring Web MVC, this is typically done within your configuration.

> For example, the following configuration will ensure that the cache headers are set for all of your resources:

```java
@EnableWebMvc
public class WebMvcConfiguration extends WebMvcConfigurerAdapter {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry
			.addResourceHandler("/resources/**")
			.addResourceLocations("/resources/")
			.setCachePeriod(31556926);
	}

	// ...
}
```

### 20.1.2 Content Type Options
> Historically browsers, including Internet Explorer, would try to guess the content type of a request using content sniffing.

> This allowed browsers to improve the user experience by guessing the content type on resources that had not specified the content type.

> For example, if a browser encountered a JavaScript file that did not have the content type specified, it would be able to guess the content type and then execute it.

> There are many additional things one should do (i.e. only display the document in a distinct domain, ensure Content-Type header is set, sanitize the document, etc) when allowing content to be uploaded.

> However, these measures are out of the scope of what Spring Security provides.

> It is also important to point out when disabling content sniffing, you must specify the content type in order for things to work properly.

> The problem with content sniffing is that this allowed malicious users to use polyglots (i.e. a file that is valid as multiple content types) to execute XSS attacks.

> For example, some sites may allow users to submit a valid postscript document to a website and view it.

> A malicious user might create a postscript document that is also a valid JavaScript file and execute a XSS attack with it.

> Content sniffing can be disabled by adding the following header to our response:

```
X-Content-Type-Options: nosniff
```

> Just as with the cache control element, the nosniff directive is added by default when using the <headers> element with no child elements.

> However, if you want more control over which headers are added you can use the <content-type-options> element and the headers@defaults-disabled attribute as shown below:

```xml
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<content-type-options />
	</headers>
</http>
```

> The X-Content-Type-Options header is added by default with Spring Security Java configuration.

> If you want more control over the headers, you can explicitly specify the content type options with the following:

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.defaultsDisabled()
		.contentTypeOptions();
}
}
```

### 20.1.3 HTTP Strict Transport Security (HSTS)
> When you type in your bank’s website, do you enter mybank.example.com or do you enter https://mybank.example.com? If you omit the https protocol, you are potentially vulnerable to Man in the Middle attacks.

> Even if the website performs a redirect to https://mybank.example.com a malicious user could intercept the initial HTTP request and manipulate the response (i.e. redirect to https://mibank.example.com and steal their credentials).

> Many users omit the https protocol and this is why HTTP Strict Transport Security (HSTS) was created.

> Once mybank.example.com is added as a HSTS host, a browser can know ahead of time that any request to mybank.example.com should be interpreted as https://mybank.example.com.

> This greatly reduces the possibility of a Man in the Middle attack occurring.

> In accordance with RFC6797, the HSTS header is only injected into HTTPS responses.

> In order for the browser to acknowledge the header, the browser must first trust the CA that signed the SSL certificate used to make the connection (not just the SSL certificate).

> One way for a site to be marked as a HSTS host is to have the host preloaded into the browser.

> Another is to add the "Strict-Transport-Security" header to the response.

> For example the following would instruct the browser to treat the domain as an HSTS host for a year (there are approximately 31536000 seconds in a year):

```
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
```

> The optional includeSubDomains directive instructs Spring Security that subdomains (i.e. secure.mybank.example.com) should also be treated as an HSTS domain.

> As with the other headers, Spring Security adds HSTS by default.

> You can customize HSTS headers with the <hsts> element as shown below:

```xml
<http>
	<!-- ... -->

	<headers>
		<hsts
			include-subdomains="true"
			max-age-seconds="31536000" />
	</headers>
</http>
```

> Similarly, you can enable only HSTS headers with Java Configuration:

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.httpStrictTransportSecurity()
			.includeSubdomains(true)
			.maxAgeSeconds(31536000);
}
}
```

