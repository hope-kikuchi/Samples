# 20. Security HTTP Response Headers
> This section discusses Spring Security’s support for adding various security headers to the response.

このセクションでは、 Spring Security がサポートするレスポンスへのセキュリティヘッダーについて議論します。

## 20.1 Default Security Headers
> Spring Security allows users to easily inject the default security headers to assist in protecting their application.

Spring Security はアプリケーションの保護を支援するためデフォルトのセキュリティヘッダーを簡単に追加することができるようになっています。

> The default for Spring Security is to include the following headers:

デフォルトで、 Spring Security は次のヘッダーを含めます。

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

> Strict-Transport-Security is only added on HTTPS requests

`Strict-Transport-Security` は HTTPS リクエストのときのみ追加されます。

> For additional details on each of these headers, refer to the corresponding sections:

これら個々のヘッダーについての追加の詳細な情報については該当する章を参照してください。

- [Cache Control](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-cache-control)
- [Content Type Options](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-content-type-options)
- [HTTP Strict Transport Security](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-hsts)
- [X-Frame-Options](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-frame-options)
- [X-XSS-Protection](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-xss-protection)

> While each of these headers are considered best practice, it should be noted that not all clients utilize the headers, so additional testing is encouraged.

これらのヘッダーはベストプラクティスを考慮されていますが、全てのクライアントがヘッダーを利用できるわけではないということに注意すべきです。
そのため、追加のテストが推奨されます。

> You can customize specific headers.
あなたは、特定のヘッダーをカスタマイズすることができます。

> For example, assume that want your HTTP response headers to look like the following:
たとえば、次のような HTTP レスポンスヘッダーが要求されたとします。

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
```

> Specifically, you want all of the default headers with the following customizations:

特にあなたは全てのデフォルトヘッダーに次のようなカスタマイズをしたいと思うでしょう。

> X-Frame-Options to allow any request from same domain

`X-Frame-Options` は同じドメインからの任意のリクエストを許可します。

> HTTP Strict Transport Security (HSTS) will not be addded to the response

HTTP Strict Transport Security はレスポンスには追加されないだろう。

> You can easily do this with the following Java Configuration:

あなたはこれを以下の Java Configuration で簡単に実行できます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers()
				.frameOptions().sameOrigin()
				.httpStrictTransportSecurity().disable();
	}
}
```

> Alternatively, if you are using Spring Security XML Configuration, you can use the following:

もしくは、 XML Configuration を使っているなら、次のようにできます。

```xml
<http>
	<!-- ... -->

	<headers>
		<frame-options policy="SAMEORIGIN" />
		<hsts disable="true"/>
	</headers>
</http>
```

> If you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults.

もしあなたがデフォルトで追加して欲しくなくて明示的に制御したいのであれば、デフォルトを無効にすることができます。

> An example for both Java and XML based configuration is provided below:

たとえば、 Java, XML 両方で次のように提供されます。

> If you are using Spring Security’s Java Configuration the following will only add Cache Control.

もしあなたが Java Configuration を使っているなら、 Cache Control の追加は次のようにするだけです。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		// do not use any default headers unless explicitly listed
		.defaultsDisabled()
		.cacheControl();
}
}
```

> The following XML will only add Cache Control.

以下の XML は Cache Control だけを追加しています。

```xml
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<cache-control/>
	</headers>
</http>
```

> If necessary, you can disable all of the HTTP Security response headers with the following Java Configuration:

もし必要なら、次のような Java Configuration で全てのセキュリティレスポンスヘッダーを無効にできます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers().disable();
}
}
```

> If necessary, you can disable all of the HTTP Security response headers with the following XML configuration below:

もし必要なら、次のような XML Configuration で全てのセキュリティレスポンスヘッダーを無効にできます。

```xml
<http>
	<!-- ... -->

	<headers disabled="true" />
</http>
```

### 20.1.1 Cache Control
> In the past Spring Security required you to provide your own cache control for your web application.

以前の Spring Security はあなたの Web アプリ独自の Cache Control を要求していました。

> This seemed reasonable at the time, but browser caches have evolved to include caches for secure connections as well.

当時、これは合理的だと考えられていました。
しかし、ブラウザのキャッシュはよりセキュアに接続を含むように進化しました。

> This means that a user may view an authenticated page, log out, and then a malicious user can use the browser history to view the cached page.

これが意味するのは、ユーザが認証済みのページを見てログアウトしたあとに、悪意あるユーザがブラウザの履歴からキャッシュされたページを見れるということです

> To help mitigate this Spring Security has added cache control support which will insert the following headers into you response.

これを移行する助けとして、レスポンスに以下のヘッダーを追加する Cache Control のサポートが Spring Security に追加されました。

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
```

> Similarly, you can enable only cache control within Java Configuration with the following:

同様に、あなたは以下のようにするだけで Java Configuration でキャッシュのコントロールを有効にできます。


```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.defaultsDisabled()
		.cacheControl();
}
}
```

> If you actually want to cache specific responses, your application can selectively invoke HttpServletResponse.setHeader(String,String) to override the header set by Spring Security.

もしあなたが実際に特定のレスポンスをキャッシュしたいのであれば、あなたのアプリケーションは Spring Securit によってセットされたヘッダーを `HttpServletResponse.setHeader(String, String)` で任意に上書きすることができます。

> This is useful to ensure things like CSS, JavaScript, and images are properly cached.

これは CSS, JavaScript そして画像を正しくキャッシュすることを確実にするのに便利です。

> When using Spring Web MVC, this is typically done within your configuration.

Spring Web MVC を使う場合、通常これは設定ファイルで行います。

> For example, the following configuration will ensure that the cache headers are set for all of your resources:

例えば、次の設定は全てのリソースについてキャッシュヘッダーが確実にセットされるようにします。

```java
@EnableWebMvc
public class WebMvcConfiguration extends WebMvcConfigurerAdapter {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry
			.addResourceHandler("/resources/**")
			.addResourceLocations("/resources/")
			.setCachePeriod(31556926);
	}

	// ...
}
```

### 20.1.2 Content Type Options
> Historically browsers, including Internet Explorer, would try to guess the content type of a request using content sniffing.

IE を含む歴史的なブラウザは、 Content Suniffing を使ってリクエストの Content Type の推測を試みます。

> This allowed browsers to improve the user experience by guessing the content type on resources that had not specified the content type.

これはリソースの Content Type が指定されていない場合に Content Type を推測することでユーザ体験を改善することになります。

> For example, if a browser encountered a JavaScript file that did not have the content type specified, it would be able to guess the content type and then execute it.

たとえば、もしブラウザが Content Type の指定されていない JavaScript ファイルに遭遇した場合、 ContentType を推測してそれを実行することができます。

> There are many additional things one should do (i.e. only display the document in a distinct domain, ensure Content-Type header is set, sanitize the document, etc) when allowing content to be uploaded.

コンテンツのアップロードを許可する場合、多くのことを加えて行わなければなりません
（たとえば、明確なドメインのみでドキュメントを表示し、確実に ContentType ヘッダーをセットし、ドキュメントをサニタイズし、その他もろもろ...）

> However, these measures are out of the scope of what Spring Security provides.

しかしながら、これらの対策は Spring Security が提供するスコープの外です。

> It is also important to point out when disabling content sniffing, you must specify the content type in order for things to work properly.

それは、 Content Sniffing を無効にするときにも重要になります。
あなたはその代わりに正しく動作するために Content Type を指定しなければなりません。

> The problem with content sniffing is that this allowed malicious users to use polyglots (i.e. a file that is valid as multiple content types) to execute XSS attacks.

Content Sniffing の問題点は、悪意あるユーザに XSS 攻撃を実行するための多彩な手段を許してしまうことです。
（たとえば、複数の Content Type を許可したファイルなど）

> For example, some sites may allow users to submit a valid postscript document to a website and view it.

たとえば、いくつかのサイトは PostScript のドキュメントをサブミットし、 Web サイト上に表示することを許可します。

> A malicious user might create a postscript document that is also a valid JavaScript file and execute a XSS attack with it.

悪意あるユーザは JavaScript ファイルとしても有効な PostScript ファイルを作り、 XSS 攻撃を実行します。

> Content sniffing can be disabled by adding the following header to our response:

Content Sniffing は次のヘッダーをレスポンスに追加することで無効にできます。

```
X-Content-Type-Options: nosniff
```

> Just as with the cache control element, the nosniff directive is added by default when using the <headers> element with no child elements.

ちょうどキャッシュ制御の要素と同じように、 nosniff ディレクティブは `<headers>` 要素を子要素なしでつかった場合はデフォルトで追加されます。

> However, if you want more control over which headers are added you can use the <content-type-options> element and the headers@defaults-disabled attribute as shown below:

しかしながら、もしあなたがヘッダーを上書きして制御したい場合、 `<content-type-options>` 要素を `header@defaults-disabled` 属性を次のようにすることで利用できます。

```xml
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<content-type-options />
	</headers>
</http>
```

> The X-Content-Type-Options header is added by default with Spring Security Java configuration.

`X-Content-Type-Options` ヘッダーは Spring Security の Java Configuration を使っている場合はデフォルトで追加されます。

> If you want more control over the headers, you can explicitly specify the content type options with the following:

もしあなたがヘッダーを上書きして制御したい場合は、次のように明示的に ContentType オプションを指定します。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.defaultsDisabled()
		.contentTypeOptions();
}
}
```

### 20.1.3 HTTP Strict Transport Security (HSTS)
> When you type in your bank’s website, do you enter mybank.example.com or do you enter https://mybank.example.com?

銀行の Web サイトをタイプするとき、あなたは `mybank.example.com` と入力しますか？ それとも `https://mybank.example.com` としますか？

> If you omit the https protocol, you are potentially vulnerable to Man in the Middle attacks.

もしあなたが `https` プロトコルを省略した場合、中間者攻撃の脆弱性を抱えている可能性があります。

※中間者攻撃とは  
通信経路上に攻撃者が割り込んで、通信の内容を盗聴すること。

> Even if the website performs a redirect to https://mybank.example.com a malicious user could intercept the initial HTTP request and manipulate the response (i.e. redirect to https://mibank.example.com and steal their credentials).

たとえ Web サイトが `https://mybank.example.com` にリダイレクトするようにふるまっていても、悪意あるユーザーは HTTP リクエストをインターセプトしてレスポンスを書き換えることができます。
（たとえば、 `https://mibank.example.com` にリダイレクトして資格情報を盗みます）

> Many users omit the https protocol and this is why HTTP Strict Transport Security (HSTS) was created.

多くのユーザーは `https` プロトコルを省略するため、 HTTP Strict Transport Security が作られた要因となっています。

※HTTP Strict Transport Security とは  
HSTS と略される。  
Web サイトに HTTPS で接続したとき、レスポンスヘッダーに `Strict-Transport-Security` が設定されている場合、ブラウザは次回以降そのサイトには HTTPS でアクセスするようになる。

これにより、プロトコルを省略したことで HTTP で通信してしまうことで中間者攻撃が成功する危険性を軽減できる。

> Once mybank.example.com is added as a HSTS host, a browser can know ahead of time that any request to mybank.example.com should be interpreted as https://mybank.example.com.

一度 `mybank.example.com` が HSTS ホストとして登録されると、ブラウザは `mybank.example.com` への任意のリクエストを送るときは `https://mybank.example.com` に翻訳すべきということを知ることができます。

> This greatly reduces the possibility of a Man in the Middle attack occurring.

これは中間者攻撃を防ぐ大きな可能性があります。

> In accordance with RFC6797, the HSTS header is only injected into HTTPS responses.

RFC6797 でアナウンスされた内容によると、 HSTS ヘッダーは HTTPS レスポンスのヘッダーにだけ設定できます。

> In order for the browser to acknowledge the header, the browser must first trust the CA that signed the SSL certificate used to make the connection (not just the SSL certificate).

ブラウザーがヘッダーを認識するためには、ブラウザーは最初に（SSL証明書だけでなく）接続に使用されたSSL証明書に署名したCAを信頼する必要があります。

> One way for a site to be marked as a HSTS host is to have the host preloaded into the browser.

サイトを HSTS ホストとしてマークする１つの方法として、ブラウザにホストをあらかじめ読み込んでおく方法があります。

> Another is to add the "Strict-Transport-Security" header to the response.

別の手段としては、 `Strict-Transport-Security` ヘッダーをレスポンスに追加する方法があります。

> For example the following would instruct the browser to treat the domain as an HSTS host for a year (there are approximately 31536000 seconds in a year):

例えば、以下はブラウザにドメインを１年間 HSTS ホストとして扱うように指示します。
（31536000 秒は、約１年です）

```
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
```

> The optional includeSubDomains directive instructs Spring Security that subdomains (i.e. secure.mybank.example.com) should also be treated as an HSTS domain.

`includeSubDomains` ディレクティブは任意で、 Spring Security にサブドメイン（例えば `secure.mybank.example.com`）も同じく HSTS ドメインとして扱うように指示します。

> As with the other headers, Spring Security adds HSTS by default.

他のヘッダー同様、 Spring Security は HSTS をデフォルトで追加します。

> You can customize HSTS headers with the <hsts> element as shown below:

HSTS ヘッダーは `<hsts>` 要素で次のようにカスタマイズすることができます。

```xml
<http>
	<!-- ... -->

	<headers>
		<hsts
			include-subdomains="true"
			max-age-seconds="31536000" />
	</headers>
</http>
```

> Similarly, you can enable only HSTS headers with Java Configuration:

同様に、 Java Configuration では HSTS のヘッダーのみを有効にすることができます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.httpStrictTransportSecurity()
			.includeSubdomains(true)
			.maxAgeSeconds(31536000);
}
}
```

### 20.1.4 HTTP Public Key Pinning (HPKP)
> HTTP Public Key Pinning (HPKP) is a security feature that tells a web client to associate a specific cryptographic public key with a certain web server to prevent Man in the Middle (MITM) attacks with forged certificates.

HTTP 公開鍵ピン止め（HPKP） は、偽造された証明書による中間者攻撃を防ぐために Web クライアントに特定の公開鍵暗号と特定の Web サーバーと関連付けるよう伝えるセキュリティ機能です。

※HPKP とは  
通常 SSL は信頼できる認証局が証明書の安全性を保障することで成り立っている。  
しかし、逆に言うと認証局をクラックできてしまうと、証明書はいくらでも偽造される危険性がある。  
そうなった場合にあらゆる SSL 通信は中間者攻撃を受ける可能性を持ってしまう。  
そこで、最初に HTTPS で通信したときに、「そのサーバーの証明書はコレ」というのをクライアントが覚えておくようにしておくことで、途中で証明書が偽物にすり替わった場合にそれを検知できるようにする仕組みが HPKP。  
レスポンスヘッダーに HPKP を有効にするヘッダーを追加することで利用が可能。

> To ensure the authenticity of a server’s public key used in TLS sessions, this public key is wrapped into a X.509 certificate which is usually signed by a certificate authority (CA).

TLS セッションで使用されるサーバーの公開鍵の信憑性を確実にするため、この公開鍵は通常認証局によって X.509 署名でラップされています。

> Web clients such as browsers trust a lot of these CAs, which can all create certificates for arbitrary domain names.

ブラウザのような Web クライアントは多くの CA を信頼しているので、認証局は任意のドメインの署名を作ることができます。

> If an attacker is able to compromise a single CA, they can perform MITM attacks on various TLS connections.

もし攻撃者が１つの認証局のクラックに成功した場合、彼らは任意の TLS コネクションで中間者攻撃を実施できるようになります。

> HPKP can circumvent this threat for the HTTPS protocol by telling the client which public key belongs to a certain web server.

HPKP はクライアントに公開鍵がどのサーバーに所属するかを教えることで、 HTTPS プロトコルでのこの脅威を回避します。

> HPKP is a Trust on First Use (TOFU) technique.

HPKP は Trsut on First Use テクニックの１つです。

※Trust on First Use とは  
その名の通り、最初の一回目を信頼するというセキュリティ対策モデルの１つ。  
当然、その一回目が既に攻撃されていた場合はアウトになるので、 100% 安全というわけではない。

> The first time a web server tells a client via a special HTTP header which public keys belong to it, the client stores this information for a given period of time.

初回に Web サーバーは特殊な HTTP ヘッダーを使ってクライアントにどの公開鍵に所属しているかを伝えます。  
クライアントはこの情報を指定された期間保持します。

> When the client visits the server again, it expects a certificate containing a public key whose fingerprint is already known via HPKP.

クライアントがサーバーに再びアクセスすると、すでに HPKP で知ったものと公開鍵の署名のフィンガープリントが一致することを期待します。

> If the server delivers an unknown public key, the client should present a warning to the user.

もしサーバーが不明な公開鍵を送ってきた場合、クライアントはユーザーに警告を提供すべきです。

> Because the user-agent needs to validate the pins against the SSL certificate chain, the HPKP header is only injected into HTTPS responses.

なぜなら、ユーザーエージェントはピン止めした SSL 証明書の妥当性をチェックする必要があり、 HPKP ヘッダーは HTTP レスポンスにだけ設定できるからです。

> Enabling this feature for your site is as simple as returning the Public-Key-Pins HTTP header when your site is accessed over HTTPS.

この機能をあなたのサイトで有効にすると、 HTTPS でアクセスしたときにシンプルな `Public-Key-Pins` という HTTP ヘッダーが返されます。

> For example, the following would instruct the user-agent to only report pin validation failures to a given URI (via the report-uri directive) for 2 pins:

例えば、次はユーザエージェントに２つのピンについてのピン検証の失敗を `report-uri` ディレクティブを通じて与えられた URL にレポートすることを指示しています。

```
Public-Key-Pins-Report-Only: max-age=5184000 ; pin-sha256="d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=" ; pin-sha256="E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=" ; report-uri="http://example.net/pkp-report" ; includeSubDomains
```

> A pin validation failure report is a standard JSON structure that can be captured either by the web application’s own API or by a publicly hosted HPKP reporting service, such as, REPORT-URI.

ピン検証の失敗は、 Web アプリケーション自身の API か公開されホストされた HPKP レポートサービス（例えば [REPORT-URI](https://report-uri.io/)）のいずれかで取得可能な一般的な JSON 構造です。

> The optional includeSubDomains directive instructs the browser to also validate subdomains with the given pins.

任意の `includeSubdomains` ディレクティブは、与えられたピンをサブドメインに対しても有効にすることを指示します。

> Opposed to the other headers, Spring Security does not add HPKP by default.

他のヘッダーとは異なり、 Spring Security は HPKP をデフォルトでは追加しません。

> You can customize HPKP headers with the <hpkp> element as shown below:

HPKP ヘッダーは `<hpkp>` 要素によって次のようにカスタマイズ可能です。

```xml
<http>
	<!-- ... -->

	<headers>
		<hpkp
			include-subdomains="true"
			report-uri="http://example.net/pkp-report">
			<pins>
					<pin algorithm="sha256">d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=</pin>
					<pin algorithm="sha256">E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=</pin>
			</pins>
		</hpkp>
	</headers>
</http>
```

> Similarly, you can enable HPKP headers with Java Configuration:

Java Configuration の場合も同様に HPKP ヘッダーを有効にできます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
				http
				// ...
				.headers()
						.httpPublicKeyPinning()
								.includeSubdomains(true)
								.reportUri("http://example.net/pkp-report")
								.addSha256Pins("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=", "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=";
		}
}
```

### [20.1.5 X-Frame-Options](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-frame-options)
> Allowing your website to be added to a frame can be a security issue.

Web サイトにセキュリティの問題となりえる frame を追加することを許可します。

> For example, using clever CSS styling users could be tricked into clicking on something that they were not intending (video demo).

例えば、賢い CSS スタイルは、ユーザーに意図しないものをクリックするよう騙すことができます。

[デモムービー](https://www.youtube.com/watch?v=3mk0RySeNsU)

※マウスに追随する形で `<iframe>` を動かし、透明にすることで別ページのボタンを気付かないうちにクリックできるようにしている。

> For example, a user that is logged into their bank might click a button that grants access to other users.

例えば、銀行のサイトにログインしたあるユーザが、他のユーザへのアクセス権を付与するボタンを押すかもしれません。

> This sort of attack is known as Clickjacking.

これはクリックジャッキング攻撃の一種として知られています。

> Another modern approach to dealing with clickjacking is to use Section 20.1.7, “Content Security Policy (CSP)”.

クリックジャッキングを扱う他の最近のアプローチについては [Section 20.1.7, “Content Security Policy (CSP)”](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-csp) を使用してください。

> There are a number ways to mitigate clickjacking attacks.

クリックジャッキング攻撃を緩和する方法はいくつかあります。

> For example, to protect legacy browsers from clickjacking attacks you can use frame breaking code.

例えば、レガシーなブラウザでクリックジャッキング攻撃を防ぐ方法として、 [frame breaking code](https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script) というものがある。

-------------------------------------------------------
#### Frame Breaking Code について
`X-Frame-Options-Header` ヘッダーをサポートしていないレガシーなブラウザでも、 `<iframe>` を使ったクリックジャッキング攻撃ができないようにするための対策方法。

ページが `<iframe>` 経由で読み込まれているかどうかを判定して、 `<iframe>` 経由で表示されている場合は現在の URL を強制的に `<iframe>` 内部の URL で書き換えてしまう。

そうすることで、気付かないうちに `<iframe>` 内のボタンを押させられていた、といったことを防ぐ。

要するに `<iframe>` 経由でページを読み込めないように強制してしまうことで、クリックジャッキング攻撃を防ぐという手法。

具体的には次のような html と JavaScript をページ内に記述することで実現できる。

```html
<!-- 現在のページ全体を強制的に非表示にする CSS 設定 -->
<style id="antiClickjack">body{display:none !important;}</style>
```

```js
if (self === top) {
		// iframe を利用せず直接開かれた場合は、すぐに <style> タグを除去する
		var antiClickjack = document.getElementById("antiClickjack");
		antiClickjack.parentNode.removeChild(antiClickjack);
} else {
		// iframe 経由で読み込まれたらこっちが実行されて、ページの URL が強制的に書き換わる
		top.location = self.location;
}
```

-------------------------------------------------------

> While not perfect, the frame breaking code is the best you can do for the legacy browsers.

しかし、これは完全ではありません。 frame breaking code はレガシーブラウザでのベストな方法です。

> A more modern approach to address clickjacking is to use X-Frame-Options header:

クリックジャッキングへのより現代的なアプローチは、 `X-Frame-Options` ヘッダーを使うことです。

```
X-Frame-Options: DENY
```

> The X-Frame-Options response header instructs the browser to prevent any site with this header in the response from being rendered within a frame.

`X-Frame-Options` のレスポンスヘッダーは、レスポンスにこのヘッダーがある場合、任意のサイトでフレーム内でレンダリングされることを防ぐようブラウザに指示します。

> By default, Spring Security disables rendering within an iframe.

デフォルトでは、 Spring Security は `iframe` でのレンダリングは無効にしています。

> You can customize X-Frame-Options with the frame-options element.

あなたは `X-Frame-Options` を `<frame-options>` 要素でカスタマイズすることができます。

> For example, the following will instruct Spring Security to use "X-Frame-Options: SAMEORIGIN" which allows iframes within the same domain:

例えば、以下は Spring Security に同一ドメインでのフレームの利用を許可するよう `X-Frame-Options: SAMEORIGIN` を使って指示しています。

```xml
<http>
	<!-- ... -->

	<headers>
		<frame-options
		policy="SAMEORIGIN" />
	</headers>
</http>
```

> Similarly, you can customize frame options to use the same origin within Java Configuration using the following:

同様に、Java Configuration だと次のような方法で同一オリジンでのフレームの使用を許可するようカスタマイズできます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.frameOptions()
			.sameOrigin();
}
}
```

### [20.1.6 X-XSS-Protection](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-xss-protection)
> Some browsers have built in support for filtering out reflected XSS attacks.

いくつかのブラウザは Refrected XSS 攻撃を回避する組み込みのサポートを持っています。

※Referected XSS 攻撃  
反射型 XSS 攻撃。リクエスト中に含まれるコードがそのまま実行されるケースの XSS 攻撃。

> This is by no means foolproof, but does assist in XSS protection.

これは決して簡単ではないが、 XSS の防御を補助します。

> The filtering is typically enabled by default, so adding the header typically just ensures it is enabled and instructs the browser what to do when a XSS attack is detected.

絞り込みは通常デフォルトで有効になっています。よって、ヘッダーを追加すると、 XSS 攻撃が検出された場合に何をすべきかをブラウザに指示します。

> For example, the filter might try to change the content in the least invasive way to still render everything.

たとえば、フィルタは、最も侵襲的な方法でコンテンツを変更して、すべてをレンダリングしようとする可能性があります。

> At times, this type of replacement can become a XSS vulnerability in itself.

時には、この種の置き換えはXSSの脆弱性となることがあります。

> Instead, it is best to block the content rather than attempt to fix it.

代わりに、コンテンツを修正しようとするのではなく、ブロックするのが良い。

> To do this we can add the following header:

これには次のヘッダーを追加します。

```
X-XSS-Protection: 1; mode=block
```

> This header is included by default.

このヘッダーはデフォルトで含まれています。

> However, we can customize it if we wanted. For example:

しかしながら、私たちは任意にカスタマイズができます。たとえば、

```xml
<http>
	<!-- ... -->

	<headers>
		<xss-protection block="false"/>
	</headers>
</http>
```

> Similarly, you can customize XSS protection within Java Configuration with the following:

同様に、次のように Java Configuration で XSS 保護をカスタマイズできます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.xssProtection()
			.block(false);
}
}
```

### [20.1.7 Content Security Policy (CSP)](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-csp)
> Content Security Policy (CSP) is a mechanism that web applications can leverage to mitigate content injection vulnerabilities, such as cross-site scripting (XSS).

Content Security Policy は、 Web アプリケーションがコンテンツインジェクション脆弱性を緩和するのに利用できるようにするメカニズムです。
例えば、 XSS などがそうです。

> CSP is a declarative policy that provides a facility for web application authors to declare and ultimately inform the client (user-agent) about the sources from which the web application expects to load resources.

CSPは、Webアプリケーション作成者が宣言し、最終的にWebアプリケーションがリソースを読み込むソースについてクライアント（ユーザーエージェント）に通知するための機能を提供する宣言型ポリシーです。

> Content Security Policy is not intended to solve all content injection vulnerabilities.

CSP は全てのコンテンツインジェクション脆弱性を解決することを意図していません。

> Instead, CSP can be leveraged to help reduce the harm caused by content injection attacks.

代わりに、 CSP はコンテンツインジェクション攻撃を原因とする問題を減らすのに活用できます。

> As a first line of defense, web application authors should validate their input and encode their output.

最初の防衛ラインとして、 Web アプリケーションの制作者は彼らの入力を検証し、出力をエンコードすべきです。

> A web application may employ the use of CSP by including one of the following HTTP headers in the response:

Webアプリケーションは、レスポンスに次のHTTPヘッダーのいずれかを含めることで、CSPを使用することができます。

- Content-Security-Policy
- Content-Security-Policy-Report-Only

> Each of these headers are used as a mechanism to deliver a security policy to the client.

これらのヘッダーは、クライアントにセキュリティポリシーを提供するためのメカニズムとして使用されます。

> A security policy contains a set of security policy directives (for example, script-src and object-src), each responsible for declaring the restrictions for a particular resource representation.

セキュリティポリシーは、特定のリソース表現についての制限を宣言したセキュリティポリシーディレクティブのセット（例えば `script-src` と `object-src`）を含んでいます。

> For example, a web application can declare that it expects to load scripts from specific, trusted sources, by including the following header in the response:

例えば、 Web アプリケーションは、次のレスポンスヘッダを含めることで、アプリケーションが特定の信頼された場所からスクリプトを読み込むことを期待していることを宣言できます。

```
Content-Security-Policy: script-src https://trustedscripts.example.com
```

> An attempt to load a script from another source other than what is declared in the script-src directive will be blocked by the user-agent.

`script-src` ディレクティブで宣言された場所とは異なる場所からスクリプトをロードしようとすると、ユーザエージェント（※ブラウザとか）によってブロックされます。

> Additionally, if the report-uri directive is declared in the security policy, then the violation will be reported by the user-agent to the declared URL.

さらに、もし `report-uri` ディレクティブがセキュリティポリシーに宣言されていた場合、違反行為はユーザエージェントによって宣言された URL に報告されます。

> For example, if a web application violates the declared security policy, the following response header will instruct the user-agent to send violation reports to the URL specified in the policy’s report-uri directive.

例えば、もし Web アプリケーションが宣言されたセキュリティポリシーに違反した場合、以下のレスポンスヘッダーはユーザーエージェントに違反のレポートをポリシーの `report-uri` ディレクティブで指定された URL に対して送信するよう指示します。

```
Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/
```

> Violation reports are standard JSON structures that can be captured either by the web application’s own API or by a publicly hosted CSP violation reporting service, such as, REPORT-URI.

違反のレポートは Web アプリケーション自身の API か、 CSP 違反レポートサービス（例えば [REPORT-URI](https://report-uri.io/)）によってホストされたポリシーのいずれかでキャプチャー可能な標準的な JSON の構造をしています。

> The Content-Security-Policy-Report-Only header provides the capability for web application authors and administrators to monitor security policies, rather than enforce them.

`Content-Security-Policy-Report-Only` ヘッダーは Web アプリケーションの作者と管理者に代わってセキュリティポリシーを監視する能力を提供します。

> This header is typically used when experimenting and/or developing security policies for a site.

このヘッダーは通常、サイトのセキュリティポリシーを検証したり開発しているときに使用します。

> When a policy is deemed effective, it can be enforced by using the Content-Security-Policy header field instead.

ポリシーが有効とみなされると、代わりに `Content-Security-Policy` ヘッダーフィールドが使用されるようになります。

> Given the following response header, the policy declares that scripts may be loaded from one of two possible sources.

以下のレスポンスヘッダーを与えて、ポリシーがスクリプトは２つの有効なソースのうち１つからロードされるということを宣言しています。

```
Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/
```

> If the site violates this policy, by attempting to load a script from evil.com, the user-agent will send a violation report to the declared URL specified by the report-uri directive, but still allow the violating resource to load nevertheless.

`evil.com` からロードしようとしたためにサイトがこのポリシーに違反した場合、ユーザーエージェントは違反レポートを `report-uri` ディレクティブで宣言された URL に送信します。
しかし、それでもまだ違反したリソースをロードすることは許可されています。

#### [Configuring Content Security Policy](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-csp-configure)
> It’s important to note that Spring Security does not add Content Security Policy by default.

 Spring Security は Content Security Policy をデフォルトでは追加しないという点に注意してください。

> The web application author must declare the security policy(s) to enforce and/or monitor for the protected resources.

Web アプリケーションの作者は、リソースの保護について実行するのかもしくは監視するのかについてセキュリティポリシーを宣言しなければなりません。

> For example, given the following security policy:

例えば、次のセキュリティポリシーを与えるとした場合、

```
script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/
```

> You can enable the CSP header using XML configuration with the <content-security-policy> element as shown below:

あなたは xml 設定を使った場合は `<content-security-policy>` 要素を以下に見るように使うことで CSP ヘッダーを有効にできます。

```xml
<http>
	<!-- ... -->

	<headers>
		<content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/" />
	</headers>
</http>
```

> To enable the CSP 'report-only' header, configure the element as follows:

CSP の `report-only` ヘッダーを有効にするには、要素を次のように設定します。

```xml
<http>
	<!-- ... -->

	<headers>
		<content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
			report-only="true" />
	</headers>
</http>
```

> Similarly, you can enable the CSP header using Java configuration as shown below:

同様に、あなたは Java Configuration を次のように使うことで CSP ヘッダーを有効にできます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.contentSecurityPolicy("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/");
}
}
```

> To enable the CSP 'report-only' header, provide the following Java configuration:

CSP の `report-only` ヘッダーを有効にするには、 Java Configuration では次のように提供します。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.contentSecurityPolicy("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
		.reportOnly();
}
}
```

#### [Additional Resources](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-csp-links)
> Applying Content Security Policy to a web application is often a non-trivial undertaking.

Web アプリケーションに Content Security Policy を適用することは、しばしば重要ではないことがあります。

> The following resources may provide further assistance in developing effective security policies for your site.

以下のリソースは効果的なセキュリティポリシーをサイトに組み込むときの助けを提供します。

[An Introduction to Content Security Policy](http://www.html5rocks.com/en/tutorials/security/content-security-policy/)

[CSP Guide - Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/Security/CSP)

[W3C Candidate Recommendation](https://www.w3.org/TR/CSP2/)

### [20.1.8 Referrer Policy](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-referrer)
> Referrer Policy is a mechanism that web applications can leverage to manage the referrer field, which contains the last page the user was on.

Referer ポリシーは Web アプリケーションがユーザーが最後にアクセスしていたページを含んだ referer フィールドを管理するようできるメカニズムです。

> Spring Security’s approach is to use Referrer Policy header, which provides different policies:

Spring Security のアプローチは、異なるポリシーを提供する Referer Policy ヘッダーを使うというものです。

```
Referrer-Policy: same-origin
```

> The Referrer-Policy response header instructs the browser to let the destination knows the source where the user was previously.

レスポンスヘッダの `Referer-Policy` はユーザが以前いた場所を知らせるようブラウザに指示します。

#### [Configuring Referrer Policy](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-referrer-configure)

> Spring Security doesn’t add Referrer Policy header by default.

Spring Security はデフォルトでは Referer Policy ヘッダーを追加しません。

> You can enable the Referrer-Policy header using XML configuration with the `<referrer-policy>` element as shown below:

あなたは、 XML 設定では `<referer-policy>` タグを次のように使用することで `Referer-Policy` ヘッダーを有効にできます。

```xml
<http>
	<!-- ... -->

	<headers>
		<referrer-policy policy="same-origin" />
	</headers>
</http>
```

> Similarly, you can enable the Referrer Policy header using Java configuration as shown below:

同様に、あなたは Java Configuration で次のようにして `Referer-Policy` を有効にできます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.referrerPolicy(ReferrerPolicy.SAME_ORIGIN);
}
}
```

## [20.2 Custom Headers](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-custom)

> Spring Security has mechanisms to make it convenient to add the more common security headers to your application.

Spring Security はより共通のセキュリティヘッダーをアプリケーションに追加することを便利にするメカニズムを持ちます。

> However, it also provides hooks to enable adding custom headers.

しかしながら、それはカスタムヘッダーを追加できるフックを提供することでもあります。

### [20.2.1 Static Headers](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-static)

> There may be times you wish to inject custom security headers into your application that are not supported out of the box.

ときどき、あなたはサポートされていないカスタムのセキュリティヘッダーをアプリケーションに追加したいと思うでしょう。

> For example, given the following custom security header:

例えば、以下のカスタムのセキュリティヘッダーを提供します。

```
X-Custom-Security-Header: header-value
```

> When using the XML namespace, these headers can be added to the response using the `<header>` element as shown below:

XML namespace を使っている場合は、レスポンスにヘッダーを追加するには `<header>` 要素を次のように使用します。

```xml
<http>
	<!-- ... -->

	<headers>
		<header name="X-Custom-Security-Header" value="header-value"/>
	</headers>
</http>
```

> Similarly, the headers could be added to the response using Java Configuration as shown in the following:

同様に、 Java Configuration でレスポンスにヘッダーを追加する場合は次のようにします。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.addHeaderWriter(new StaticHeadersWriter("X-Custom-Security-Header","header-value"));
}
}
```

### [20.2.2 Headers Writer](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-writer)

> When the namespace or Java configuration does not support the headers you want, you can create a custom HeadersWriter instance or even provide a custom implementation of the HeadersWriter.

namespace か Java Configuration がサポートしていないヘッダーが必要となった場合は、カスタムの `HeaderWriter` インスタンスを生成するか、カスタムの実装を提供することができます。

> Let’s take a look at an example of using an custom instance of XFrameOptionsHeaderWriter.

`XFrameOptionsHeaderWriter` のカスタムインスタンスを使用する例を見てみましょう。

> Perhaps you want to allow framing of content for the same origin.

おそらく、あなたは同じオリジンでのコンテンツのフレームかを許可したいと思うでしょう。

> This is easily supported by setting the policy attribute to "SAMEORIGIN", but let’s take a look at a more explicit example using the ref attribute.

これは、 "SAMEORIGIN" をポリシーの属性にセットすることで簡単にサポートされています。
しかし、 `ref` 属性を使用したより明示的な例を見てください。

```xml
<http>
	<!-- ... -->

	<headers>
		<header ref="frameOptionsWriter"/>
	</headers>
</http>
<!-- Requires the c-namespace.
See http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace
-->
<beans:bean id="frameOptionsWriter"
	class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"
	c:frameOptionsMode="SAMEORIGIN"/>
```

> We could also restrict framing of content to the same origin with Java configuration:

私たちは、 Java Configuration で同じオリジンでコンテンツをフレーム化することを制限することもできます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN));
}
}
```

### [20.2.3 DelegatingRequestMatcherHeaderWriter](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-delegatingrequestmatcherheaderwriter)

> At times you may want to only write a header for certain requests.

> For example, perhaps you want to only protect your log in page from being framed.

> You could use the DelegatingRequestMatcherHeaderWriter to do so.

> When using the XML namespace configuration, this can be done with the following:

```xml
<http>
	<!-- ... -->

	<headers>
		<frame-options disabled="true"/>
		<header ref="headerWriter"/>
	</headers>
</http>

<beans:bean id="headerWriter"
	class="org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter">
	<beans:constructor-arg>
		<bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"
			c:pattern="/login"/>
	</beans:constructor-arg>
	<beans:constructor-arg>
		<beans:bean
			class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"/>
	</beans:constructor-arg>
</beans:bean>
```

> We could also prevent framing of content to the log in page using java configuration:

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	RequestMatcher matcher = new AntPathRequestMatcher("/login");
	DelegatingRequestMatcherHeaderWriter headerWriter =
		new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter());
	http
	// ...
	.headers()
		.frameOptions().disabled()
		.addHeaderWriter(headerWriter);
}
}
```

