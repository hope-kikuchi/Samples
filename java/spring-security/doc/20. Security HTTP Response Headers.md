# 20. Security HTTP Response Headers
> This section discusses Spring Security’s support for adding various security headers to the response.

このセクションでは、 Spring Security がサポートするレスポンスへのセキュリティヘッダーについて議論します。

## 20.1 Default Security Headers
> Spring Security allows users to easily inject the default security headers to assist in protecting their application.

Spring Security はアプリケーションの保護を支援するためデフォルトのセキュリティヘッダーを簡単に追加することができるようになっています。

> The default for Spring Security is to include the following headers:

デフォルトで、 Spring Security は次のヘッダーを含めます。

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

> Strict-Transport-Security is only added on HTTPS requests

`Strict-Transport-Security` は HTTPS リクエストのときのみ追加されます。

> For additional details on each of these headers, refer to the corresponding sections:

これら個々のヘッダーについての追加の詳細な情報については該当する章を参照してください。

- [Cache Control](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-cache-control)
- [Content Type Options](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-content-type-options)
- [HTTP Strict Transport Security](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-hsts)
- [X-Frame-Options](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-frame-options)
- [X-XSS-Protection](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers-xss-protection)

> While each of these headers are considered best practice, it should be noted that not all clients utilize the headers, so additional testing is encouraged.

これらのヘッダーはベストプラクティスを考慮されていますが、全てのクライアントがヘッダーを利用できるわけではないということに注意すべきです。
そのため、追加のテストが推奨されます。

> You can customize specific headers.
あなたは、特定のヘッダーをカスタマイズすることができます。

> For example, assume that want your HTTP response headers to look like the following:
たとえば、次のような HTTP レスポンスヘッダーが要求されたとします。

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
```

> Specifically, you want all of the default headers with the following customizations:

特にあなたは全てのデフォルトヘッダーに次のようなカスタマイズをしたいと思うでしょう。

> X-Frame-Options to allow any request from same domain

`X-Frame-Options` は同じドメインからの任意のリクエストを許可します。

> HTTP Strict Transport Security (HSTS) will not be addded to the response

HTTP Strict Transport Security はレスポンスには追加されないだろう。

> You can easily do this with the following Java Configuration:

あなたはこれを以下の Java Configuration で簡単に実行できます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers()
				.frameOptions().sameOrigin()
				.httpStrictTransportSecurity().disable();
	}
}
```

> Alternatively, if you are using Spring Security XML Configuration, you can use the following:

もしくは、 XML Configuration を使っているなら、次のようにできます。

```xml
<http>
	<!-- ... -->

	<headers>
		<frame-options policy="SAMEORIGIN" />
		<hsts disable="true"/>
	</headers>
</http>
```

> If you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults.

もしあなたがデフォルトで追加して欲しくなくて明示的に制御したいのであれば、デフォルトを無効にすることができます。

> An example for both Java and XML based configuration is provided below:

たとえば、 Java, XML 両方で次のように提供されます。

> If you are using Spring Security’s Java Configuration the following will only add Cache Control.

もしあなたが Java Configuration を使っているなら、 Cache Control の追加は次のようにするだけです。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		// do not use any default headers unless explicitly listed
		.defaultsDisabled()
		.cacheControl();
}
}
```

> The following XML will only add Cache Control.

以下の XML は Cache Control だけを追加しています。

```xml
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<cache-control/>
	</headers>
</http>
```

> If necessary, you can disable all of the HTTP Security response headers with the following Java Configuration:

もし必要なら、次のような Java Configuration で全てのセキュリティレスポンスヘッダーを無効にできます。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers().disable();
}
}
```

> If necessary, you can disable all of the HTTP Security response headers with the following XML configuration below:

もし必要なら、次のような XML Configuration で全てのセキュリティレスポンスヘッダーを無効にできます。

```xml
<http>
	<!-- ... -->

	<headers disabled="true" />
</http>
```

### 20.1.1 Cache Control
> In the past Spring Security required you to provide your own cache control for your web application.

以前の Spring Security はあなたの Web アプリ独自の Cache Control を要求していました。

> This seemed reasonable at the time, but browser caches have evolved to include caches for secure connections as well.

当時、これは合理的だと考えられていました。
しかし、ブラウザのキャッシュはよりセキュアに接続を含むように進化しました。

> This means that a user may view an authenticated page, log out, and then a malicious user can use the browser history to view the cached page.

これが意味するのは、ユーザが認証済みのページを見てログアウトしたあとに、悪意あるユーザがブラウザの履歴からキャッシュされたページを見れるということです

> To help mitigate this Spring Security has added cache control support which will insert the following headers into you response.

これを移行する助けとして、レスポンスに以下のヘッダーを追加する Cache Control のサポートが Spring Security に追加されました。

```
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
```

> Similarly, you can enable only cache control within Java Configuration with the following:

同様に、あなたは以下のようにするだけで Java Configuration でキャッシュのコントロールを有効にできます。


```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.defaultsDisabled()
		.cacheControl();
}
}
```

> If you actually want to cache specific responses, your application can selectively invoke HttpServletResponse.setHeader(String,String) to override the header set by Spring Security.

もしあなたが実際に特定のレスポンスをキャッシュしたいのであれば、あなたのアプリケーションは Spring Securit によってセットされたヘッダーを `HttpServletResponse.setHeader(String, String)` で任意に上書きすることができます。

> This is useful to ensure things like CSS, JavaScript, and images are properly cached.

これは CSS, JavaScript そして画像を正しくキャッシュすることを確実にするのに便利です。

> When using Spring Web MVC, this is typically done within your configuration.

Spring Web MVC を使う場合、通常これは設定ファイルで行います。

> For example, the following configuration will ensure that the cache headers are set for all of your resources:

例えば、次の設定は全てのリソースについてキャッシュヘッダーが確実にセットされるようにします。

```java
@EnableWebMvc
public class WebMvcConfiguration extends WebMvcConfigurerAdapter {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry
			.addResourceHandler("/resources/**")
			.addResourceLocations("/resources/")
			.setCachePeriod(31556926);
	}

	// ...
}
```

### 20.1.2 Content Type Options
> Historically browsers, including Internet Explorer, would try to guess the content type of a request using content sniffing.

IE を含む歴史的なブラウザは、 Content Suniffing を使ってリクエストの Content Type の推測を試みます。

> This allowed browsers to improve the user experience by guessing the content type on resources that had not specified the content type.

これはリソースの Content Type が指定されていない場合に Content Type を推測することでユーザ体験を改善することになります。

> For example, if a browser encountered a JavaScript file that did not have the content type specified, it would be able to guess the content type and then execute it.

たとえば、もしブラウザが Content Type の指定されていない JavaScript ファイルに遭遇した場合、 ContentType を推測してそれを実行することができます。

> There are many additional things one should do (i.e. only display the document in a distinct domain, ensure Content-Type header is set, sanitize the document, etc) when allowing content to be uploaded.

コンテンツのアップロードを許可する場合、多くのことを加えて行わなければなりません
（たとえば、明確なドメインのみでドキュメントを表示し、確実に ContentType ヘッダーをセットし、ドキュメントをサニタイズし、その他もろもろ...）

> However, these measures are out of the scope of what Spring Security provides.

しかしながら、これらの対策は Spring Security が提供するスコープの外です。

> It is also important to point out when disabling content sniffing, you must specify the content type in order for things to work properly.

それは、 Content Sniffing を無効にするときにも重要になります。
あなたはその代わりに正しく動作するために Content Type を指定しなければなりません。

> The problem with content sniffing is that this allowed malicious users to use polyglots (i.e. a file that is valid as multiple content types) to execute XSS attacks.

Content Sniffing の問題点は、悪意あるユーザに XSS 攻撃を実行するための多彩な手段を許してしまうことです。
（たとえば、複数の Content Type を許可したファイルなど）

> For example, some sites may allow users to submit a valid postscript document to a website and view it.

たとえば、いくつかのサイトは PostScript のドキュメントをサブミットし、 Web サイト上に表示することを許可します。

> A malicious user might create a postscript document that is also a valid JavaScript file and execute a XSS attack with it.

悪意あるユーザは JavaScript ファイルとしても有効な PostScript ファイルを作り、 XSS 攻撃を実行します。

> Content sniffing can be disabled by adding the following header to our response:

Content Sniffing は次のヘッダーをレスポンスに追加することで無効にできます。

```
X-Content-Type-Options: nosniff
```

> Just as with the cache control element, the nosniff directive is added by default when using the <headers> element with no child elements.

ちょうどキャッシュ制御の要素と同じように、 nosniff ディレクティブは `<headers>` 要素を子要素なしでつかった場合はデフォルトで追加されます。

> However, if you want more control over which headers are added you can use the <content-type-options> element and the headers@defaults-disabled attribute as shown below:

しかしながら、もしあなたがヘッダーを上書きして制御したい場合、 `<content-type-options>` 要素を `header@defaults-disabled` 属性を次のようにすることで利用できます。

```xml
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<content-type-options />
	</headers>
</http>
```

> The X-Content-Type-Options header is added by default with Spring Security Java configuration.

`X-Content-Type-Options` ヘッダーは Spring Security の Java Configuration を使っている場合はデフォルトで追加されます。

> If you want more control over the headers, you can explicitly specify the content type options with the following:

もしあなたがヘッダーを上書きして制御したい場合は、次のように明示的に ContentType オプションを指定します。

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.defaultsDisabled()
		.contentTypeOptions();
}
}
```

### 20.1.3 HTTP Strict Transport Security (HSTS)
> When you type in your bank’s website, do you enter mybank.example.com or do you enter https://mybank.example.com?

銀行の Web サイトをタイプするとき、あなたは `mybank.example.com` と入力しますか？ それとも `https://mybank.example.com` としますか？

> If you omit the https protocol, you are potentially vulnerable to Man in the Middle attacks.

もしあなたが `https` プロトコルを省略した場合、中間者攻撃の脆弱性を抱えている可能性があります。

※中間者攻撃とは  
通信経路上に攻撃者が割り込んで、通信の内容を盗聴すること。

> Even if the website performs a redirect to https://mybank.example.com a malicious user could intercept the initial HTTP request and manipulate the response (i.e. redirect to https://mibank.example.com and steal their credentials).

たとえ Web サイトが `https://mybank.example.com` にリダイレクトするようにふるまっていても、悪意あるユーザーは HTTP リクエストをインターセプトしてレスポンスを書き換えることができます。
（たとえば、 `https://mibank.example.com` にリダイレクトして資格情報を盗みます）

> Many users omit the https protocol and this is why HTTP Strict Transport Security (HSTS) was created.

多くのユーザーは `https` プロトコルを省略するため、 HTTP Strict Transport Security が作られた要因となっています。

※HTTP Strict Transport Security とは  
HSTS と略される。  
Web サイトに HTTPS で接続したとき、レスポンスヘッダーに `Strict-Transport-Security` が設定されている場合、ブラウザは次回以降そのサイトには HTTPS でアクセスするようになる。

これにより、プロトコルを省略したことで HTTP で通信してしまうことで中間者攻撃が成功する危険性を軽減できる。

> Once mybank.example.com is added as a HSTS host, a browser can know ahead of time that any request to mybank.example.com should be interpreted as https://mybank.example.com.



> This greatly reduces the possibility of a Man in the Middle attack occurring.

> In accordance with RFC6797, the HSTS header is only injected into HTTPS responses.

> In order for the browser to acknowledge the header, the browser must first trust the CA that signed the SSL certificate used to make the connection (not just the SSL certificate).

> One way for a site to be marked as a HSTS host is to have the host preloaded into the browser.

> Another is to add the "Strict-Transport-Security" header to the response.

> For example the following would instruct the browser to treat the domain as an HSTS host for a year (there are approximately 31536000 seconds in a year):

```
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
```

> The optional includeSubDomains directive instructs Spring Security that subdomains (i.e. secure.mybank.example.com) should also be treated as an HSTS domain.

> As with the other headers, Spring Security adds HSTS by default.

> You can customize HSTS headers with the <hsts> element as shown below:

```xml
<http>
	<!-- ... -->

	<headers>
		<hsts
			include-subdomains="true"
			max-age-seconds="31536000" />
	</headers>
</http>
```

> Similarly, you can enable only HSTS headers with Java Configuration:

```java
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

@Override
protected void configure(HttpSecurity http) throws Exception {
	http
	// ...
	.headers()
		.httpStrictTransportSecurity()
			.includeSubdomains(true)
			.maxAgeSeconds(31536000);
}
}
```

