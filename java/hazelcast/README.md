# Hazelcast
- https://hazelcast.org/

## Hello World
https://hazelcast.org/getting-started-with-hazelcast/

### やること
- 2つのノード(JVM)でインメモリ・データグリッドを作成する
- 最終的には、外部の Java アプリケーションからデータグリッドにアクセスする

### インストール
https://hazelcast.org/download/

```groovy
compile 'com.hazelcast:hazelcast:3.10.6'
```

## ノードを自動検出する仕組み
https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#discovery-mechanisms

- 一度クラスタを組んだノード同士の通信は TCP/IP によって行われている
    - これは、ノードの発見方法とは関係しない
- 発見メカニズム (Discovery Mechanisms)
    - 単純な TCP による発見以外にも、 AWS 上でノードを見つける方法や Azure で見つける方法など、様々な方法が用意されている
- 基本は xml の設定ファイルでクラスタの情報を定義するっぽい
    - 設定がないときは、デフォルトでローカルホスの 5701, 5702 ポートに接続しようとするっぽい

## トポロジー
- クラスタの組み方が二種類存在する
- 組み込み(Embedded)と、クラサバ(Client/Server)
- 組み込み
    - 非同期・ハイパフォーマンス・大量タスクの実行に向いている
    - アプリケーションの中に Hazelcast を組み込む
    - データアクセスのレイテンシ(待ち時間)が減るのがメリット
- クラサバ
    - Hazelcast だけでデータサーバーを構築し、そこにアプリケーションがアクセスしにいく形式
    - クライアントになるアプリケーションは、個々に独立した存在になれる
        - 異なるアーキテクチャで構築できる
        - 個々のクライアントアプリケーションごとにスケールできる
    - Hazelcast のクライアント API を使ってアクセスする
        - Java, .NET, C++ は専用のクライアント API ライブラリが用意されている
        - REST API もある
    - メリット
        - Hazelcast だけに絞ったスケールが容易

## データパーティション
- shard (シャード)
    - 破片
    - 分割されたデータのことか？
- Hazelcast では、シャードのことを**パーティション**(Partitions)と呼んでいる
- パーティションとは、メモリセグメントのこと
    - 中に数百から数千のデータを格納できる
    - 実際どれくらい保存できるかは、実行環境のメモリ容量に依存する
- パーティションは複数の複製を持つことができる
    - それらは（複製のこと指している？）、クラスタの各メンバーに分配される
    - １つの複製が**プライマリ** (primary)となる
    - それ以外の複製は**バックアップ** (buckups)となる
    - プライマリを持つクラスタメンバのことを **プライマリオーナー** (primary owner) と呼ぶ
- データにアクセスすると、オーナーに対して透過的に対話が行われる
    - どれがオーナーかとかは意識することなく、クラスタ内からデータを引っ張り出せる、ってことかな
- デフォルトだと、１つ目に立ち上がったノードでは 271 のパーティションが作成される
    - この時点では、 271 のパーティションがすべてプライマリということになる
        - クラスタ化されていないので、複製がない状態ということ
- ２つ目のノードを立ち上げてクラスタが組まれると、２つ目のノードに１つ目のノードのパーティションがコピーされる
    - そして、半分の 135 のパーティションが、それぞれで重複しない形でプライマリパーティションになる
    - 残りの 136 は、バックアップとなる
- 3.6 で追加された Lite メンバーは、自分のパーティションを持っていない
    - 代わりに、クラスタ内の他のノードのパーティションを見ることができる
- どのようにしてデータがパーティションに分けられるのか
    - Hazelcast は、ハッシュアルゴリズムを使ってデータをパーティション内に配布する
    - オブジェクトの名前をハッシュ化してパーティションの数の剰余を取得する
        - オブジェクトの名前は、 HazelcastInstance から getList(String) とかしたときに引数で指定するやつ
        - 他にも Key というのもあるらしいが、よくわかってない
    - 剰余の結果がパーティションの ID になり、そのパーティションにデータが割り振られる
- パーティションテーブル
    - ノードを作成すると、内部でパーティションテーブルが作られる
    - テーブルには次の情報が格納されている
        - パーティションID
        - そのパーティションが、クラスタ内のどのノードに所属しているか
            - どれがオーナーか、ということ？
    - このテーブルの目的は、クラスタ内の全メンバーが、あるパーティションのオーナーがどのメンバーかを知ること
        - そのデータがどこにあるかがわかる
    - 最初に作成されたメンバーが、定期的にパーティションテーブルの情報を他のメンバーに送信している
        - 情報を受け取ったメンバーは、オーナーがどう変化したかを知ることができる
        - 最初に作成されたメンバーがクラスタから外れた場合は、次に古いメンバーが役割を引き継ぐ
    - パーティションテーブルの情報を送信する頻度は変更できる
        - `hazelcast.partition.table.send.interval`
        - デフォルトは 15 秒
- 再パーティション(Repartitioning)
    - 再パーティションとは、パーティションの所有者を再割り当てする処理のことを言う
    - 次のような場合に、再パーティションが行われる
        - メンバーがクラスタに参加した
        - メンバーがクラスタから離脱した
    - 最も古株のノードが持つパーティションテーブルが、新しいオーナーの情報で更新される
    - ただし、 Lite メンバーが参加・離脱しても再パーティションは行われない
        - Lite メンバーは自身のパーティションを持たないため
- パーティションの中にデータが入っているわけではないっぽい
    - 名前からパーティションを決定し、パーティションテーブルでオーナーを特定するというステップを踏むことで、効率的に分散されたデータにアクセスできるようになっている、ということか

## 設定ファイルを理解する
https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#understanding-configuration

- Hazelcast の設定方法には以下の種類が存在する
    1. 宣言的な方法
    2. プログラミングによる方法
    3. Hazelcast のシステムプロパティを使用する方法
    4. Spring Context に含める方法
    5. 実行中のクラスで動的に設定を追加する方法(3.9 以上)
- 宣言的な方法
    - xml ファイルで設定を定義する
    - jar の中の `hazelcast-default.xml` がデフォルト値を定義した設定ファイル
    - `hazelcast-full-example.xml` は、全ての設定値を含むファイル
        - リファレンスドキュメントとして利用できる
- 設定ファイルの合成
    - `<import>` を使うことで、外部の設定ファイルをロードできる
- 設定ファイルをプログラムから読み込む
    - 設定ファイルの取得元ごとに `Config` クラスのサブクラスが用意されている
        - URL を指定して読み込む場合は `UrlXmlConfig`
        - ローカルファイルを読み込む場合は `FileSystemXmlConfig`
        - クラスパス上の設定ファイルを読み込む場合は `ClasspathXmlConfig`
- 動的な設定の追加
    - 普通、設定は静的で、一度インスタンスを生成すると変更することはできない
    - しかし、 3.9 からは一部の設定に限ってインスタンス生成後も設定を追加できるようになった
    - `Config` クラスで `add*Config()` という名前のメソッドが対象
    - `HazelcastInstance` の `getConfig()` で取得した `Config` インスタンスを使用するのが前提
    - 動的に追加する設定は、 `add*Config()` を呼び出す前に全て完了している必要がある
    - 動的に追加された設定は、クラスタ内の全てのノードに配布される
    - もしネットワークエラーなどの原因でクラスタ内のノードに配布できなかった場合
        - クラスタ内のメンバーの変更を検出するたびに内部的に再試行が行われる
        - `add*Config()` メソッドが例外を投げた場合は、ユーザ操作で再試行を行わなければならない
    - 設定ファイルの競合を制御する
        - 動的に追加した設定と同じ要素が、すでに静的な設定で指定されている場合
        - `ConfigurationException` がスローされる
        - 以前の動的な設定追加ものと同じ要素を、更に動的設定追加しようとした場合も `ConfigurationException` がスローされる
- 設定ファイルの検索
    - `Config` クラスを使わずに `HazelcastInstance` を生成した場合の挙動
        - `newHazelcastInstance()` を引数なしで使用した場合の話
    - デフォルトでは、次の順序で設定ファイルが検索される
        1. システムプロパティの `hazelcast.config` で指定されたファイル
            - `classpath:` で始めれば、クラスパス内のファイルを参照することも可能
        2. ワーキングディレクトリの `hazelcast.xml`
        3. クラスパス内の `hazelcast.xml`
        4. Hazelcast が内部に持つデフォルト値を設定した `hazelcast.xml`
- パターンマッチ
    - ワイルドカード
        - 分散データ構造の名前ではワイルドカードが使える
        - デフォルトでは、 `*` を使ったワイルドカードの指定がサポートされている
        - １つの名前の指定で `*` が使えるのは１回だけ
        - ある分散データ構造のインスタンス名が複数の設定とマッチした場合は、名前の指定が長い方が優先される
            - `mymap.customer.name` という名前のデータがあったとして、
            - `mymap.*` と `mymap.customer.*` という２つの設定が合った場合は、長い方の `mymap.customer.*` が優先される
    - 正規表現
        - パターンマッチのルールは任意のものに変更できる
        - 標準実装のなかに正規表現クラスがあるっぽいので、それに差し替えできそう
        
- 変数
    - システムプロパティに設定した値は、 `${名前}` という記法で設定ファイルに埋め込むことができる
    - `XmlConfigBuilder` に `setProperties(Properties)` を設定して `build()` で生成した設定ファイルを使えば、システムプロパティ以外で設定できる
    - `ClasspathXmlConfig` のコンストラクタは内部で `XmlConfigBuilder` を使っている
        - 引数に `Properties` を指定できるコンストラクタを使えば、内部で `XmlConfigBuilder` が利用されている
    - `FileSystemXmlConfig` とかも一緒
- 変数置換(Variable Replacers)
    - 設定ファイルを読み込むときに任意の値に置換する機能
    - パスワードのような機密情報などを扱うときに利用する
        - もちろん、それ以外の用途でも利用できる
    - `ConfigReplacter` インターフェースを実装して作成する
    - 標準で以下が用意されている
        - `EncryptionReplacer`
        - `PropertyReplacer`
    - 設定ファイル中に `$<PREFIX>{<VALUE>}` と指定しているときに、 `<PREFIX>` ごとに `Replacer` が適用され、 `<VALUE>` の値をもとに別の値に置換される
    - `EncryptionReplacer`
        - 暗号化された変数を置換する
        - プレフィックスは `ENC`
            - `$ENC{....}`
        - ファイル内の値にできるパスワードのために暗号化/復号化された秘密鍵は、MAC アドレスや実際のユーザデータのような環境固有の値から生成できる
        - 設定のためのプロパティ
            - `cipherAlgorithm`
                - 暗号化/復号化のためのアルゴリズム
                - デフォルトは AES
            - `keyLengthBits`
                - 生成される鍵のビット数
                - デフォルトは 128
            - `passwordFile`
                - 生成される暗号化パスワードの一部として利用するファイルのパス
                    - ファイルの内容をバイト配列で取得して Base64 でエンコードしたものをパスワードにするっぽい
                - 設定していない場合は利用されない
                - デフォルトは null
            - `passwordNetworkInterface`
                - パスワードの一部に使用する MAC アドレスを持つネットワークインターフェースの名前
                - 未設定の場合は利用されない
                - デフォルトは null
            - `passwordUserProperties`
                - `user.home` と `user.name` のシステムプロパティを使用してパスワードを生成するかどうか
                - デフォルトは true
            - `passwordFile`, `passwordNetworkInterface`, `passwordUserProperties` は、最低でも１つは設定（null でない or true）されている必要がある
            - `saltLengthBytes`
                - ランダムソルトのバイト数
                - デフォルトは 8 byte
            - `secretKeyAlgorithm`
                - 秘密鍵のアルゴリズム
                    - `SecretKeySpec` のコンストラクタの第二引数で渡す値
                - デフォルトが AES
            - `secretKeyFactoryAlgorithm`
                - パスワードから秘密鍵を生成するときのアルゴリズム
                    - `SecretKeyFactory.getInstance()` に渡す値
                - デフォルトは `PBKDF2WithHmacSHA256`
            - `securityProvider`
                - 秘密鍵のファクトリと暗号を見つけるための Java Security Provider の名前
                - デフォルトは null
        - `EncryptionReplacer` の `main()` 関数に暗号化したい引数を渡して実行すると、所定のフォーマットで暗号化された文字列が標準出力に出力される
            - 例：`$ENC{L6xyXa0XvK8=:531:OcTxoUoPYzQc+ZQop8IApA==}`
        - これを設定ファイルの任意の値に埋め込む
        - `<config-replacers>` で `com.hazelcast.config.replacer.EncryptionReplacer` を指定して設定ファイルを読み込む
        - すると、暗号化された値を `Config` から取得したときの値が復号化した状態で取得できる
    - `PropertyReplacer`
        - `${key}` と指定すると、 `key` という名前のシステムプロパティに置き換える
        - この `Replacer` は明示的な設定が不要で、デフォルトで動作する
        - プレフィックスは空文字
            - `${...}`
    - カスタムの Replacer
        - `ConfigReplacer` インターフェースを実装して作成する
        - `init(Properties)`
            - 最初に１回だけ呼ばれるメソッド
            - 引数の `Properties` は、設定ファイルの `<replacer>` 内の `<properties>` で指定している値が渡される
        - `getPrefix()`
            - カスタム Replacer のプレフィックスを返す
        - `getReplacement(String)`
            - 設定ファイルから取得されたマスク値が引数に渡されるので、置換後の値を返す

## 5. クラスタのセットアップ
https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#setting-up-clusters

- 発見の仕組み
    - Hazelcast は自動的にクラスタに参加する仕組みを持つ
    - クラスタに参加するためのメカニズムは複数存在する
    - クラスタに参加したあとは、発見のメカニズムに関係なく TCP/IP で通信が行われる
    - TCP
        - 設定ファイルに以下を記述する必要がある
            - 全てのメンバーのホスト名かそのサブセット
            - メンバーの IP アドレス
        - クラスタ内の全てのメンバーを記述する必要はないが、新規にクラスタに参加するときには最低１つはアクティブである必要がある
        - TCP/IP を使用するには、以下のように設定を変更する
            - `network.join.multicast` の `enabled` 属性に `false` を設定する
            - `network.join.tcp-ip` の `enabled` 属性を `true` にする
            - `tcp-ip` の下にクラスタメンバの情報を記述する
                - `<member>` タグで記述
                    - ホスト名や IP アドレスを記述できる
                    - `192.168.1.0-7` のように範囲指定の記述が可能
                    - `192.168.1.1:5799` のようにポートの指定も可能
                        - ポートを指定していない場合は、 `5701` から順番にトライする
                        - おそらく、 `network.port` で指定した情報でトライのポート範囲が決まる
                - `<members>` タグなら、カンマ区切りで複数記述することも可能
            - ポートの指定がない場合、
    - Multicast
        - デフォルトで true ？
        - 本番環境での利用は推奨されないらしい
        - UDP を使うため接続が壊れることがある
        - 他のメカニズムのほうが確実
- クラスタのグループを作る
    - `<group>` タグを使うことで、クラスタのグループを作ることができる
    - グループは名前をつけて分けることができる
    - プログラムからグループを宣言することも可能
    - １つの JVM の上で、複数の HazelcastInstance を起動できる
        - それぞれ別々のグループで起動できる
        - 同じグループでも起動できる
    - 3.8 以前であれば、 `<password>` も合わせて設定する必要があった
        - 3.8 からはなくても良くなった
- パーティショングループの設定
    - データはパーティションに割り振られる
    - デフォルトでは、 Hazelcast は全てのパーティションを平等に扱う
    - しかし、もしあるメンバーが同じ JVM 上で動いていたり、物理的に同じ筐体の上で動いていた場合、物理的に異なるメンバーに割り振るように制御したくなるかもしれない
    - また、メンバーごとにマシン性能が異なるような場合は、パーティションの分割数なども同じにしたくないかもしれない
    - そういうときのために、パーティションのグループを作ることができるようになっている
    - グループ単位で、パーティションの数を設定できる


