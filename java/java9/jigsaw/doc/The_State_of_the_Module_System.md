[The State of the Module System](http://openjdk.java.net/projects/jigsaw/spec/sotms/) の勉強メモ.

## 2.3 Readability
- モジュールAがモジュールBに依存している場合
    - モジュールグラフ上で、AがBに直接接続(依存)している
    - A は B を「読む」(`reads`)と表現する
    - 逆に、 B は A から「読み取れる」(`readable`)と表現する
- 直接依存していない場合は読むことはできない
    - `transitive` をつけている場合は別
- モジュールグラフによって定義される読み取り性の関連は、「信頼できる設定(`reliable configuration`)」の基礎となっている
    - モジュールシステムは、全ての依存関係が他のいずれかのモジュール１つに定まることを確実にする
        - ある依存関係Aがあったとき、Aがモジュールαとモジュールβの両方にある、といった状態にはならないようにする
    - これは循環しないモジュールグラフによって実現される
    - 全てのモジュールは、パッケージを提供するモジュールを最大で１つだけ読み取る
    - 同じ名前のパッケージが干渉しあうことはない
        - ことなるモジュールで同名のパッケージがあるとエラー
- 「信頼できる設定」は、信頼性だけでなくパフォーマンスの改善にもつながる
    - ある名前のパッケージが存在するのは１つのモジュールだけなので、１つ見つけたら他のモジュールを検索する必要はない

## 2.4 Accessibility
- モジュールが読み取れるだけでは、まだ型アクセスできるとは限らない
- モジュールが読み取れて、かつ対象の型を含むパッケージが exports されている必要がある

## 2.5 Implied readability
- `transitive` の前身的な話っぽいのでパス

# 3 COMPATIBILITY & MIGRATION
## 3.1 The unnamed module
- 既知のモジュール上に存在しない型のロードがリクエストされると、モジュールシステムはクラスパスを検索する
- もし型がクラスパス上で見つかった場合は、無名モジュールと呼ばれる特殊なモジュールのメンバーとして型を認識する
- 全ての型は何かしらのモジュールに属することになる
- 無名モジュールは、デフォルトパッケージ（無名パッケージ）と同じようなコンセプトに属する
    - モジュールに割り当てられていない型に割り当てられるデフォルトモジュール、みたいな感じ
- 無名モジュール以外のモジュール（普通のモジュール・自動モジュール）は、必ず名前を持っている
- 無名モジュールは、他の全てのモジュールを読み込むことができる
    - 読み取り可能なモジュールで export された型であれば参照可能
    - 全ての名前付きモジュールと、組み込みプラットフォームモジュールが対象
- Java SE 8 でコンパイル・実行できるクラスパスを使ったアプリケーションは、そのままの形で Java SE 9 でも実行できる
    - 標準 API だけを使っていて、非推奨 API は使っていない前提
- 無名モジュールは、自身の全てのパッケージを exports している扱いになる
    - ただし、これは名前付きモジュールから無名モジュールにアクセスできるという意味ではない
    - 名前付きモジュールは、無名モジュールへの依存性を宣言できない
    - この挙動は意図的なもの
        - 名前付きモジュールがクラスパス上の任意の型に依存できるようにしてしまうと、「信頼できる設定(reliable configuration)」が不可能になるため
- 名前付きモジュールと無名モジュールの両方に同じ名前のパッケージが存在した場合、無名モジュールのパッケージは無視される
    - ★これは本当か検証したい（無視ということは、エラーにすらならない？）

## 3.2 Bottom-up migration

## 3.3 Automatic modules
- 使用している全てのアーティファクトをモジュール化できるとは限らない
    - 更新の切れたサードパーティのライブラリとか
    - 更新は終わっていないが、あまり頻繁にはされないライブラリとか
- アーティファクトをクラスパスではなくモジュールパスに設定することで、自動モジュールとして扱うことができる
- 他の通常の名前付きモジュールは、通常の手段で自動モジュールに対して依存関係を定義できる
    - 自動モジュールは、普通の名前付きモジュールと同じように扱える
- 自動モジュールはその性質上、他のモジュールへの依存関係を定義する方法がない
    - 依存関係を定義するための `module-info.java` を置けない（置いていない）ので
    - そのため、自動モジュールは他の全てのモジュールを読み取れる扱いになる
    - つまり、他のモジュールを全て requires している扱いになる
- また、同様に自動モジュールには exports を定義する術がないので、全てのパッケージは exports されている扱いになる
- 自動モジュールが２段階で依存している場合に、推移的な依存関係はどうなる？
    - ★要検証

# 5 ADVANCED TOPICS
## 5.1 Reflection
- リフレクションを使ってモジュールを動的に定義できる
- Class オブジェクトには属する Module オブジェクトが割り当てられている

## 5.2 Reflection readability
- Class::forName は、コンテキストクラスローダ（`Thread.getContextClassLoader()`）がそのクラスによってロードできる限り、モジュールシステムでも利用できる
- ただし、リフレクションの newInstance() メソッドによるコンストラクタ呼び出しは機能しない
- モジュール定義で requires していない限りはアクセスできない

ここは opens で解決されている話な気がするのでパス

## 5.3 Class Loaders
- 全ての型とモジュールは、実行時にクラスローダを持つ
- クラスローダはモジュールを持つか？
    - モジュールシステムは、クラスローダとモジュールの間の関連についてはほとんど制限を設けていない
- クラスローダは、１つのモジュールからでも、もしくは複数のモジュールからでも型をロードできる
    - 以下の条件が満たされる場合に限り可
        - モジュール間で干渉しないこと
        - モジュール内の任意の型が、ただ１つのクラスローダによってロードされること
    - 言い換えると
        - モジュール間で干渉していたらだめ
            - 同じ型が複数のモジュールに存在するとか？
        - モジュール内の任意の型が、複数のクラスローダによってロードされている
- 