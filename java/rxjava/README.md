# RxJava の基礎知識
- RxJava とは
    - Java でリアクティブプログラミングを行うためのライブラリ
    - 2.0 から Reative Streams の仕様を実装
        - Reactive Stream の API に依存している
    - Java 6 以上をサポート
    - 元は .NET Framework の Reactive Extensions というライブラリだった
    - オープンソース化され、 Netflix が Java に移植した
        - Java 以外にも JavaScript や Swift にも移植されている
    - 特徴
        - オブザーバーパターンを拡張している
            - 完了通知、エラー通知を追加
        - Reactive Streams のルールに従っている限り、スレッド管理のわずらわしさから解放される
        - 同期処理でも非同期処理でも、実装が大きく変わらない
        - 関数型プログラミングの影響を受けている
            - 関数型インターフェースを受け取るメソッド
- リアクティブプログラミングとは
    - プログラミングの考え方の１つ
    - データの通知に対して関連するプログラムが反応（リアクション）するようにプログラミングする
    - データストリーム
        - 全てのデータをまとめて扱うのではなく、次々と変化するデータが順次流れてくる
        - イベントもデータストリームとみなすことができる
            - 文字列入力
                - 入力のたびに入力情報が流れてくる
            - ボタンクリック
                - クリックしたというイベントが流れてくる
    - 必要なデータを自ら取得して処理するのではなく、データを受け取ったら、それに反応して処理をするというスタイル
    - リスナーを利用した実装との違い
        - 意識の違い
        - リアクティブプログラミングは、反応する側が流れてきたデータに対してアクションを取る、という意識
        - リスナーがサブスクライバに対して命令している意識だとリアクティブプログラミングではない
        - 意識の違いは、責任範囲に影響を与える
            - 単純な処理だと実装レベルでは違いがないかもしれない
            - 複雑になってくると、意識の違いによって責任範囲が変わり、実装に差が出てくる
    - 責任範囲
        - データの生産側
            - データを渡すまでが責任範囲
            - 消費者がどう使うかは知らない
            - 消費者の処理を待つ必要もない
                - 生産者と消費者を別スレッドにできる
                - ノンブロッキングと親和性が高い
- リアクティブシステム
    - リアクティブプログラミングで構築したシステム、**ではない**
    - メッセージを送ることで処理を行う
    - スケールアウト・インが自動的に行うことで障害に強くする
    - 常に迅速に応答できる
- Reactive Streams とは
    - データストリームを非同期で扱うための共通の仕組み
    - 言語やライブラリを跨って共通のインターフェースを定義する
    - リアクティブプログラミングが広まるにつれ、様々なライブラリが作られるようになった
    - API が統一されておらず、混沌とした状態になっていた
    - データストリームを非同期で扱うための最小限の API を定めたものとして Reactive Streams が策定された
    - Java 用の API
    - RxJava 2.0 は、この Reactive Streams を実装している
- 実験的な API
    - `@Beta`
    - `@Experimental`
    - 以上のアノテーションがついている API は実験的なものなので、使わないほうがいい

# 02 Reactive Streams について
- Reactive Streams が提供するのはインターフェースのみ
    - 各言語・各ライブラリが実装を提供する
- 生産者(Publisher)と消費者(Subscriber)に分かれる
- Publisher
    - データを生成する
- Subscriber
    - Publisher が生成したデータを購読（受け取って処理）する
- プロトコル
    1. Publisher は通知の準備ができたことを Subscriber に伝える
    2. Subscriber は、受け取るデータ数のリクエストを送る
        - Subscriber がデータ数をリクエストするまで、 Publisher は待機している
    3. Publisher はデータを生成し、 Subscriber に送る
    4. Subscriber はデータを受け取って処理を実行する
    5. 要求された数だけデータを送り終わったら、 Publisher は再び待機状態になる
    6. Subscriber は処理を終えたら、次のデータ数のリクエストを送る
    7. 全てのデータを送信し終えたら、 Publisher は完了を通知する
    8. 完了通知後は、 Publisher は何も通知を行わなくなる
    - エラーが発生した場合はエラーを通知する
- Subscriber がデータ数をリクエストすることで、 Publisher からのデータ数を抑制できる
    - Publisher のデータ生成速度が速い場合に、 Subscriber が溢れないようにするため
- インターフェース
    - `Publisher`
        - データの生産者
    - `Subscriber`
        - データの購読者
    - `Subscription`
        - データ数のリクエスト・購読のキャンセルを行う
        - `Subscriber` の `onSbscribe()` メソッドの引数で受け取る
    - `Processor`
        - Publisher と Subscriber 両方の性質を持つ
- Reactive Streams のルール
    - 根本ルール
        - 購読開始の通知は１度しか通知されない
            - `Subscriber` の `onSubscribe` は１度だけ呼ばれる
        - 通知はシーケンシャルに行う
            - 通知が複数同時に来ることはない
        - null を通知しない
        - Publisher は完了もしくはエラーを通知して終了する
    - その他のルール
        - データ数のリクエストに `Long.MAX_VALUE` を渡すと、データ数は無制限扱いになる
            - 最初にリクエストしたデータ数を処理し終わる前に次のデータ数をリクエストした場合、データ数が加算されていく
            - 加算の結果が `Long.MAX_VALUE` に達した場合も、無制限扱いになってしまうので注意
        - `Subscription` のメソッドは同期された状態で呼ばなければならない

# 03 RxJavaの基本となる仕組み
## 生産者と消費者
- RxJava の仕組みは「生産者」と「消費者」に分かれる
- Reactive Streams の対応有無によって、おおきく２つが用意されている
    - Reactive Streams の対応あり
        - 生産者 `Flowable`
        - 消費者 `Subscriber`
    - Reactive Streams の対応なし
        - 生産者 `Observable`
        - 消費者 `Observer`
- `Observable` にはバックプレッシャーの機能がない
    - 通知するデータ数を制御できない
        - データが作成されるとすぐに通知される
    - `Disposable` という購読解除だけができるインターフェースを使う
- `Observable` は Reactive Streams のインターフェースを実装していないが、基本的な使い方は同じ

## オペレータ
- 通知するデータを加工したり絞り込んだりしたりするメソッドを **オペレータ** と呼ぶ
- 実装的には、 `Flowable` と `Observable` からメソッドチェーンでつなげていく感じになる
    - Java 8 の Streams API みたいな感じ

```java
Flowable<Integer> flowable =
    Flowable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
            .filter(data -> data % 2 == 0)
            .map(data -> data * 100);

flowable.subscribe(data -> System.out.println("data=" + data));
```

- オペレータは関数型プログラミングを意識して使用したほうがいい
- 各オペレータに渡す処理は純粋関数にする
    - 副作用を持たせない
    - 同じ入力に対して同じ結果を返す

## 非同期処理
- 生産者と消費者が別れているため、それぞれを別スレッドで実行しやすくなっている
    - 消費側が、受け取るデータの内容だけに依存するようにしていれば、生産者側がどう動いていようが関係ない
- 処理の用途に合わせたスレッド管理を行う `Subscriber` が用意されている
- `Subscriber` を指定できる箇所は２つ
    - データを通知する箇所
        - 生産者側が `Subscriber` を指定する
    - データを受け取る箇所
        - 消費者側で制御する
- オペレータは必ず非同期実行しても問題ないように実装しなければならない
    - 外部の状態に依存しない
- 外部の状態にアクセスするのは次のときに絞る
    - 生産者がデータを作るとき
    - 消費者がデータの処理結果を外部に反映するとき
        - 外部が非同期アクセスしても大丈夫なようにする必要はある
        - 他のプログラムが同じデータにアクセスしていないかなど

## Cold と Hot の生産者
- 生産者には Cold と Hot の２種類が存在する
- Cold な生産者
    - １つの購読(Subscribe)に対して１つの消費者だけが結びつく
- Hot な生産者
    - １つの購読に対して複数の消費者が紐付ける
    - 後から消費者を増やすこともできる
        - すでに流れたデータは無視され、途中からデータを受け取るようになる
- RxJava で生成した生産者は、最初は Cold
- Hot にするには、 Cold な生産者の変換メソッドを使用する
    - 別の方法もあるが後述
- Hot な生産者を表すインターフェース
    - `ConnectableFlowable`
    - `ConnectableObservable`

## ConnectableFlowable/ConnectableObservable
- `subscribe()` メソッドを実行しても（購読を開始しても）データは流れてこない
- `connect()` メソッドを呼ぶ必要がある
- `Flowable`, `Observable` に変換するメソッドもある

### refCount
- `ConnectableFlowable`/`ConnectableObservable` から新しい `Flowable`/`Observable` を生成する
- ★ちょっとよくわからん...

### autoConnect
- 指定された数だけ購読(subscribe)されたら処理を開始する `Flowable`/`Observable`を生成する

### Flowable/Observable を「Cold」から「Hot」に変換するオペレータ
- `publish`
    - Cold な `Flowable`/`Observable` から `ConnectableFlowable`/ `ConnectableObservable` を生成する
    - 後から購読を開始した場合は、それ以降のデータだけを受け取ることができる
- `replay`
    - Cold な `Flowable`/`Observable` から `ConnectableFlowable`/ `ConnectableObservable` を生成する
    - 後から購読を開始した場合でも、最初のデータから受け取ることができる
        - データをキャッシュしている
        - キャッシュする個数や期間は引数で指定できる
- `share`
    - `ConnectableFlowable`/`ConnectableObservable` は生成しない
    - しかし、複数の消費者から購読できるようになる

# 04 マーブルダイアグラム
- リアクティブプログラミングで、時間とともにデータがどのように処理されていくかを表現した図
- 一番上のラインが、大本のデータの入力を表すタイムライン
- 中間処理が間に入り、縦の点線がデータが処理される様子を表現
- 一番下のラインが最終的に通知されるデータを表現するタイムライン
- 各データは色と形で表現される
- 左から右へ時間の流れを表現している
- 上から下が処理の流れを表現している

# 05 サンプルの作成
- `Flowable.create(FlowableOnSubscribe, BackpressureStrategy)` でデータの通知方法を制御できる `Flowable` を作成できる
- `FlowableOnSubscribe` は `create(FlowableEmitter)` を唯一持つ関数型インターフェース
- 引数の `FlowableEmitter` を通じて、 `Subscriber` にデータを通知する
    - `onNext()` で次のデータを通知する
    - 購読がキャンセルされているかどうかは `isCancelled()` で確認できる
        - 購読がキャンセルされた場合は、速やかに処理を終了させる必要がある
        - キャンセルされたあとで `onNext()` を読んでも、 RxJava 側で通知が行かないように制御はしてくれている
        - しかし、 `create()` 内の処理が中断されているわけではないので、自発的に処理を中断させないと、無駄な処理を続けてしまうことになる
    - 通知が正常に完了したら `onComplete()` を呼ぶ
- `create()` メソッドは `Exception` を `throws` 宣言に持つ
    - 例外がスローされたら、自動的にエラー終了が `Subscriber` に通知される
- `onComplete()`, `onError()` の後には、処理を書いてはいけない
    - もし `onComplete()` のあとに書いた処理が例外をスローしても、そのことは `Subscriber` に通知されない
- `create()` メソッドの第二引数にはバックプレッシャーの種類を指定する
    - `BackpressureStrategy` 列挙型に定義された定数を使用する
    - `BUFFER`
        - 通知されるまでバッファする
    - `DROP`
        - 通知できるようになるまで、新規データは破棄する
    - `LATEST`
        - 最新データのみバッファし、古いデータは破棄していく
    - `ERROR`
        - バッファサイズまでバッファし、オーバーした場合はエラーにする
    - `NONE`
        - 特に何もしない
        - `onBackpressure()` で具体的な処理を実装する
- `Subscriber` では４つのメソッドを実装する
    - `onSubscribe(Subscription)`
        - 通知の準備が完了したときに呼ばれる
        - 引数の `Subscription` で、次に受け取るデータ数をリクエストできる
            - データスをリクエストしないと通知が始まらないので注意
            - `request()` メソッドを呼ぶのは、 `onSubscribe()` の最後でないといけない
        - 引数の `Subscription` はその後の処理でも使用するので、インスタンス変数に保存しておく
        - `Subscription` には `cancel()` メソッドで購読を中止する機能もある
            - 普通 `onNext()` の中で特定の条件を満たしたときに `cancel()` することになる
            - しかし、そもそも通知がなく `onNext()` が呼ばれていないと `cancel()` すら実行されない可能性があることに注意
    - `onNext(T)`
        - `Flowable` が通知したデータを受け取ったときに呼ばれる
        - 通知されたデータは引数で受け取れる
        - メソッドの最後で `Subscription` のデータ数をリクエストするメソッドを再度実行することで、次のデータが通知される
    - `onComplete()`
        - 購読が全て正常終了したときに呼ばれる
    - `onError(Throwable)`
        - 購読でエラーが発生したときに呼ばれる
        - 引数には `Flowable` で発生した例外オブジェクトが渡される

## スレッド管理
- `Flowable` の `observeOn(Scheduler)` を使うと、 `Flowable` と `Subscriber` を別々のスレッドで動作させることができる
- `Scheduler` はスレッド管理を行うオブジェクト
- `Flowable` と `Subscriber` を同じスレッドで実行すると、 `Subscriber` の処理が終わるまで `Flowable` は処理を待機することになる
- ２つを別スレッドに分ければ、 `Subscriber` の処理の終了を待つことなく、 `Flowable` はデータの生成ができる
    - データの生成が早い場合は、バックプレッシャー機能によって通知が制御される
    - サンプルでは `BUFFER` を指定しているので、通知はバッファされていく

## Observable を使った場合
- バックプレッシャーの機能が無い以外は、 `Flowable` と使い方は同じ
- `isCancelled()` ではなく `isDisposed()` のように、若干のメソッド名の差はあるが、基本機能は一緒

## Observable と Flowable の使い分け
- `Flowable` を使うケース
    - 大量のデータを扱う(数万件)
    - ネットワーク・データベースの IO を使う
    - 通知されるデータが非常に多い
        - バックプレッシャーを利用して限界値を設定し、それを超えたら `MissingBackpressureException` をスローさせてエラーハンドリングをする
    - 通知されるデータが全て必要というわけではない
        - DROP を選択するなどの選択肢がある
- `Observable` を使うケース
    - GUI イベント
    - 少量のデータを扱う(数千件)
    - 同期的な処理
    - Stream API の代わり
- `Observable` のほうがオーバーヘッドは少ない
- 環境や通知するデータ、その使い方などごとに使い分けが必要
- それぞれの特性をよく理解しておくことが重要

# 06 RxJava の全体像
- `Flowable` と `Observable`
    - データを生産し通知するクラス
    - `Flowable` にはバックプレッシャー機能がある
    - `Observable` にはない
- `Subscriber` と `Observer`
    - 通知されたデータを処理するクラス
    - `Subscriber` はバックプレッシャー機能があるので、データ数のリクエストが必要
        - リクエストは `onSubscribe()` の最後に実行しないと、初期化処理の途中で通知が始まってしまう
    - `Observer` にはない
- `Processor`/`Subject`
    - `Processor`
        - `Publisher` と `Subscriber` の両方を継承したインターフェース
    - `Subject`
        - `Observable` と `Observer` の両方を継承したインターフェース   

# RxJava とデザインパターン
- RxJava は Observer パターンを拡張している
- Observer パターン
    - 対象のオブジェクトの状態に変化があったときに、観察しているオブジェクトが処理を行うときのパターン
    - 観察対象のオブジェクトに変化があったときに、観察対象自身が変化を通知する
    - Subject と Observer が分離されている
        - Subject は、変化が起こったときの処理を知る必要がない
    - Observer の増加にも強い
- RxJava は生産者が Subject, 消費者が Observer にあたる
    - イベントや状態変化をデータストリームとして扱う
- RxJava では、準備完了の通知や正常終了・異常終了の通知という拡張がある

## RxJava と Iterator パターン
- RxJava は Iterator パターンの構想に影響を受けている
    - 実装上の作りは異なる
- データの集合体に対してシーケンシャルに処理を行っていく
- Iterator を使う側は、データの集合体がどのようにデータを保持しているかを知る必要がない
    - Iterator を介してだけデータを取得する
- RxJava では、生産者がデータをシーケンシャルに送る Iterator の役割を持つ
- Iterator は、利用側が自発的に Iterator からデータを取り出すプル型なのに対して、 RxJava はデータを消費者に送り出すプッシュ型という点が異なる
    - プッシュ型だとまだ生成できていないデータを待機することができる
    - プル型だとデータが無ければそこで処理が終了してしまう
        - hasNext() が false を返して終了してしまう
    - 無限に生成されるデータや、いつデータが生成されるかわからないイベントのようなデータストリームを扱うことができる
- データを１つずつ処理していく点は共通している
    - マルチスレッドの複雑さを排除できる

# RxJava の非同期処理
- デフォルトでは、生産者も消費者も同じスレッド上で実行される
- つまり、消費者の処理が終了するまで生産者の処理は待たされる
- interval(), timer() メソッドで生成した Flowable は、メインスレッドとは別のスレッドで動作する
    - あくまで、生産者と消費者は同じスレッド
- RxJava は、生産者と消費者の役割を分離するように設計するのがいい
    - 生産者はデータの生成にだけ責任を持ち
    - 消費者は受け取ったデータの処理にだけ責任を持つ
    - 消費者がどうデータを処理するのか生産者は知る必要は無いし、
    - どうデータが生産されたかなどは、消費者は知る必要はない
- 役割が分離できていると、それぞれを別スレッドに分けても問題なくなる
- RxJava では生産者側のスレッドを制御する subscribeOn() メソッドと消費者側のスレッドを制御する observeOn() の２つのメソッドが用意されている

## Scheduler
- RxJava が用意しているスレッド管理のためのクラス
- Schedulers のメソッドでインスタンスを取得する
    - computation()
        - プロセッサ数と同じ数だけプールしたスレッドをキャッシュする
        - IO処理では使用しない
    - io()
        - IO処理用のスレッドプールを生成する
        - 必要に応じて新規スレッドを生成する
    - single()
        - 単一スレッドを生成する
    - newThread()
        - 毎回新規スレッドを生成する
    - from(Executor)
        - Executor からスレッドを取得する
    - trampoline()
        - 処理をキューに入れて処理が開けば実行される
- computation() と io() の違い
    - io() は、スレッドプールに空きスレッドがない場合に、新しいスレッドを生成する
        - IO が発生する処理では、 IO の待機時間がありえる
        - そのため、プロセッサ数以上のスレッドを生成しても効率が良い可能性がある
    - computation() は論理プロセッサ数以上のスレッドは生成しない
        - コンピューティング処理には待機が発生しない
        - 論理プロセッサ数以上のスレッドを生成すると、スレッドの切り替えにオーバーヘッドがかかり逆に遅くなる可能性がある
    - io() で生成されるスレッドは、 IO 処理の共有には適さない
- interval() や timer() など、メインスレッドとは別のスレッドで実行されるメソッドを使用すると、その時点で Scheduler が設定されたことになる
    - 後述する通り、 Scheduler の指定は通常１度きりなので、この後で subscribeOn などで Scheduler を指定しても無視されるので注意

### subscribeOn
- 生産者のスレッド管理を指定する
- このメソッドは１度しか効果がない
    - ２回以降使用しても、無視される

### observeOn
- 消費者側のスレッド管理を指定する
- subscribeOn とは異なり、何度も指定できる
    - observeOn で指定した後のオペレータは、直前で指定された Scheduler が使用される
- 第二引数に boolean, 第三引数に int を受け取るオーバーロードされたメソッドがある
    - boolean delayError
        - true の場合、エラーが発生してもバッファされたデータの通知が終わるまではエラーの通知を待機する
        - false の場合は、エラーが発生したすぐにそのことが通知される
        - デフォルトは false
    - int bufferSize
        - 通知待ちデータのバッファサイズ
        - デフォルトは 128
- observeOn を使用すると、バックプレッシャーのリクエスト数にバッファサイズが利用される
    - つまり、 Subscriber 側でリクエスト数を指定しても無視される
    - バックプレッシャーのストラテジを DROP にしていると、バッファサイズを超えたデータは破棄されるようになるので注意

### flatMap
- データを受け取ると新しい Flowable/Observable を生成する
- 生成した Flowable/Observable が生成したデータを受け取った順番で Subscriber/Observer に通知する
- flatMap 内で生成した新しい Flowable/Observable が別スレッドで動くようになっている場合、スレッドごとの処理時間次第では最初のデータの並び通りにならなくなる
    - 最初に処理が完了したスレッドのデータから通知されるようになる

### concatMap
- 受け取ったデータの順番に Flowable/Observable を生成し、順番に実行していく
- １つのデータに対して生成した Flowable/Observable の処理が終了するまで、次のデータの処理は待機させられる
- つまり、 Flowable/Observable を別スレッドで実行していても、全て最初のデータ順にシーケンシャルに実行される

### concatMapEager
- concatMap とは違って、生成した Flowable/Observable は即座に実行される
- しかし、最後に結果を消費者に通知するときには、元のデータの順序で整列されて通知される
- [a, b, c] という入力データに対して、 Flowable/Observable の処理を介した結果を [f(a), f(b), f(c)] とする
- たとえ処理の完了順序が f(b) -> f(c) -> f(a) であったとしても、最終的な消費者に通知されるデータは [f(a), f(b), f(c)] となり、元データの順序が保存される
- 順序とパフォーマンスが両立できるメリットがあるが、代わりに処理が完了するまでデータをキャッシュするので、メモリを消費する点に注意が必要

## 異なるスレッド上で共有されるオブジェクト
- 異なるスレッドで動く２つの Flowable/Observable をそのまま実行すると、消費者側で共通のデータを参照しているときに同期が必要になる
    - RxJava では、消費者への通知は常にシーケンシャルに行われる
    - 消費者側を非同期(observeOn())にしていても、消費者側の処理が同時に複数呼ばれるわけではない
    - あくまで消費者のスレッドは１つで、データも順次送られる
    - 複数の Flowable/Observable を用意している場合、それぞれの消費者が別々のスレッドで動くことになる
- 複数のスレッドで動く Flowable/Observable をまとめることができる
    - Flowable.merge(Floeable...)
    - マルチスレッドで同時に通知を受け取っても、最終的な消費者にはシーケンシャルにデータが渡されるようになる

# RxJava のエラーハンドリング
- エラーの種類
    - すぐに処理を止めるべきエラー
    - 再実行すれば回復するかもしれないエラー
    - 代替データを通知して正常終了させるエラー
- 消費者でエラー処理を実装していない場合、デフォルトでは例外のスタックトレースが標準出力に出力されるだけ

## 処理の再実行
- エラーが発生した場合、生産者の処理を最初からやり直す方法がある
    - 消費者にはエラーは通知されない
- retry() メソッドでリトライができるようになる
    - 引数にリトライ回数を指定する
    - この回数を超えてエラーが発生した場合は、エラーが消費者に通知される
    - この場合、あらゆるエラーでリトライされてしまう
        - 復旧不可能でリトライが不要な場合でもリトライしてしまう
- retry(Function) メソッドなら、リトライの条件を定義できる
    - 引数の関数で例外を受け取れるので、リトライするかどうかを boolean で返す

## 代替データによる通知
- エラーが発生したときに代替データを渡し、正常終了させる方法が用意されている
- onError, onException で始まる名前のメソッドを使う
    - onErrorReturnItem()
        - 引数で指定した値を代替値として通知する
- エラーが発生したら代替値が通知され、全体の購読もそこで終了する
    - エラーとなったデータより後にもデータが残っていても、それらは通知されない
    - あたかも、そこで購読が正常終了したかのようになる
- 消費者には「完了」が通知される
- リトライ同様、代替データを渡すかどうかを判断する関数を渡すメソッドも用意されている

# RxJava のリソース管理 
- ファイルやDBコネクションなど外部リソースの管理をする方法
- 購読の開始でリソースを開いて、完了 or エラーの通知のときにクローズする

## using メソッド
- リソース管理のためのメソッド
- 第一引数
    - リソースを開いて、リソースにアクセスするオブジェクトを返す
- 第二引数
    - 第一引数で生成したオブジェクトを受け取り、通知するデータを生成する Flowable を返す
- 第三引数
    - 第一引数で開いたオブジェクトを閉じる処理を行う
    - 購読解除のタイミングで呼ばれる

## setCancellable
- FlowableEmitter の setCancellable() メソッドでキャンセル時の処理を登録できる
- このメソッドは、正常終了/異常終了時、そしてキャンセル時に実行される

# 05 RxJava のバックプレッシャー
- バックプレッシャーとは
    - データを通知する量を抑制する機能のこと
- 必要となるケース
    - 生産者と消費者が異なるスレッドで動く
    - 生産者のほうが消費者よりも速い
- 生産者のデータ生成が早すぎて、処理待ちデータが溜まってしまう
- メモリを圧迫する
- 消費者が、処理できるデータ数を生産者にリクエストする
- 生産者はリクエストされた数だけのデータを通知する
- まずデータ数のリクエストをしないと、通知が開始されない

## request メソッド
- Subscriber の onSubscribe(Subscription) で受け取る Subscription に、データ数をリクエストする request(long) メソッドが用意されている

## observeOn メソッドとバックプレッシャー
- observeOn() を使うと、生産者と消費者の間に新しい Flowable が１つ挟まる
- この Flowable が、バッファサイズ分だけ request() を送る
- 最後の消費者で request() を送ると、このバッファされたデータから通知される
- つまり、バッファサイズを超えて生産者に request() を送ることはできない
- バッファサイズは、デフォルトは 128 で、 observeOn() の第３引数で指定可能
    - システムプロパティで変更することも可能
    - `rx2.buffer-size`
- どこで request データ数の制御を行っているかを明確にするために、 observeOn() 以外の消費者での request() は Long.MAX_VALUE にして制限無しにしておくのがいい
- そして、実際の制限は observeOn() のバッファサイズで行うと、どこでデータ数を制御しているかがはっきりする

### MissingBackpressureException
- 通知されるデータ数が多くなりすぎてバッファを溢れたりした場合に、 MissingBackpressureException がスローされる
- 例外は消費者の onError() に通知される
- このエラーが発生した場合に再実行するのか完全に処理を終了させるのかは、アプリケーションの特質による

## メソッドによる通知するデータ量の制御
- バックプレッシャー機能以外にも、データ量を調整する仕組みがある
- スロットリング(Throttling)
    - データの通知が一定時間止まるのを待ってから通知を行う制御
    - ユーザの入力したテキストを処理するときなどに使う
        - ユーザが入力している最中に都度都度処理をするのではなく、最後まで入力を待ってから確定された入力文字列に対して処理を行ったほうが効率がいい
- buffer メソッドと window メソッド
    - 通知されるデータをある程度まとめて、コレクションに詰めて一気に消費者側に通知する
    - 通知回数が減らせる
    - buffer
        - List などのコレクションにまとめる
    - window
        - Flowable/Observable にまとめる

# 4 Flowable と Observable のオペレータ
- オペレータ
    - Flowable や Observable のようなデータを通知するものを生成するメソッドの総称
- Flowable/Observable を生成するオペレータ
    - just
        - 引数で指定したデータを通知する Flowable/Observable を生成する
        - 最大１０個指定可能
    - fromArray/fromIterable
        - 配列や Iterable から取得したデータを通知する
    - fromCallable
        - Callable が返したデータを通知する
    - range/rangeLong
        - 開始値と、データ数を指定して通知する
        - range(10, 3) なら 10, 11, 12 が通知される
    - interval
        - 指定した間隔で0から始まる数値を通知する
        - デフォルトでは Schedulers.computation() で生成された Scheduler 上で動作する
            - 変更する場合は Scheduler を指定できるメソッドを使用する
        - 最初の 0 は、インターバルで指定した時間待ってから通知される
            - 最初の待機時間 (initialDelay) を指定すれば変更可能
        - ほっとくと無限にデータを通知しつづけるので、 take() メソッドなどで個数を制限する必要がある
    - timer
        - 指定時間後に 0 を通知する
    - defer
        - 購読されるたびに新しい Flowable/Observable を生成する
        - 購読されて初めてデータの作成を開始するような場合に使用する
    - empty
        - 空の Flowable/Observable を生成する
        - 完了通知だけする
        - null を通知する代わりに空の Flowable/Observable を生成するといった使い方がある
    - error
        - エラーのみを通知する
        - 常にエラー通知をして終了
    - never
        - 何も通知しない
        - 完了やエラーも通tいしない
- 通知するデータを変換するオペレータ
    - map
        - データを変換する
        - Steram の map と同じ
    - flatMap
        - データを Flowable/Observable に変換して、それが持つデータを通知する
        - Stream の flatMap と同じ
        - 空の Flowable/Observable を返せばそのデータの通知をスキップできる
        - flatMap(mapper, combiner)
            - もともと通知されたデータと、 mapper が返した Flowable/Observable が combiner に渡される
            - combiner が返したデータが通知される
    - concatMap
        - flatMap と同じように動く
        - ただし、マルチスレッドで動かすときの動作が違う
        - flatMap は mapper がデータを作成すると次々データを通知する
        - concatMap は、もとのデータの順序と同じ順序で mapper が生成した Flowable/Observable が実行され、データが通知される
        - つまり、非同期でも順序が保証される
        - ただし、パフォーマンスは影響を受ける
    - concatMapEager
        - concatMap の場合は各 Flowable/Observable の処理が順次実行される
        - concatMapEager は、各 Flowable/Observable が即座に実行される
        - 最終的なデータの通知順序は concatMap と同じように調整される
    - toMap
        - 通知データを受け取り、その通知データのキーを返すようにする
        - 通知されるデータは単一の Map になる
        - 第二引数で値を返す関数を渡せば、元の通知データ以外の値を Map の値に割り当てられる
        - 複数の通知データで同じキーを返すと、最後に処理された通知データが採用される（上書きされる）
    - toMultimap
        - Map<K, Collection<V>> を生成する
        - 同じキーを返しても上書きされることはなく、 Collection に追加されていく
    - distinct
        - すでに通知したものと同じデータがきた場合は通知しない
        - つまり、通知データの重複を除去する
        - 引数に、通知データを受け取って比較する値を返す関数を渡せる
    - distinctUntilChanged
        - 連続して同じ通知データが来た場合は通知しない
        - 異なるデータが間に挟まった場合は、以前通知したものと同じデータでも通知する
            - A -> A -> B -> A
            - ２つ目の A は通知されないが、 4 つ目の A は通知される
    - take
        - 通知するデータの数や期間を指定する
        - long を渡した場合は、データ数を絞る
        - long と TimeUnit を渡した場合は、通知する期間を絞る
            - 非同期で通知しているときに、指定時間が過ぎたら通知が止まる感じ
    - takeUntil
        - 指定した条件を満たすまで通知を続ける
        - 引数に Predicate を渡すケースでは、 true を返すまで通知が続く
        - 引数に別の Flowable を渡した場合は、その Flowable がデータの通知を開始するまで元の Flowable が通知を続ける
    - takeWhile
        - 指定した条件の間だけ通知を続ける
        - 引数で指定した Predicate が false を返すまで通知が続く
    - takeLast
        - 通知データの最後尾から指定した数の分だけデータを通知する
        - 通知が完了した後に最後尾からデータが取得される
            - 完了しない Flowable には使えない
    - skip
        - 指定した数だけ先頭のデータの通知を飛ばす
    - skipUntil
        - 指定した Flowable がデータを通知するまで先頭データを通知しない（データを捨てる）
    - skipWhile
        - 引数で指定した Predicate が false を返すまで先頭データを通知せず破棄する
    - skipLast
        - 末尾から指定した数だけデータを通知しない
    - throttleFirst
        - データ通知後、指定した時間はデータを通知せず破棄する
        - 短時間に大量のデータが来るが全てが必要ではないようなケース（ユーザのキーボード入力とか？）で利用する
        - 待機中でも完了やエラーは通知される
    - throttleLast
        - 指定した期間の最後に通知されたデータだけを後続に通知する
    - throttleWithTimeout
        - データを受け取ってから指定期間次のデータを受け取らなければ、そのデータを通知する
    - elementAt
        - 指定したインデックスのデータのみ通知する
        - インデックスは通知されるデータに順番に割り当てられる０始まりの正数
        - 指定されたインデックスのデータが存在しない可能性があるので、戻り値の型が Maybe or Single になる
            - Maybe は、多分 Optional みたいなのだと思う
            - データがない場合は完了通知の Maybe が返されるらしい
        - 第二引数でインデックスに該当するデータがない場合のデフォルト値を指定できる
            - この場合、戻り値の型は Single になる
        - elementAtOrError なら、インデックスに該当するデータがなければエラー(NoSuchElementException)になる
- Flowable/Observable を結合するオペレータ
    - merge
        - 複数の Flowable が通知するデータを統合して１つのタイムラインにまとめる
        - Flowable のどれか１つでもエラーを通知した場合は、そこでエラーが通知されてタイムラインは終了する
        - mergeDelayError を使った場合は、エラーが通知されても他の Flowable の処理が完了するまではエラー通知が待機される
            - 他の Flowable の通知が完了した後でエラーが通知される
    - concat
        - 2つの Flowable を結合して１つのタイムラインで通知する
        - Flowable は１つ目の Flowable が実行されてから、２つ目が実行される
        - １つ目の Flowable が完了しないと、２つ目の Flowable は実行されない
    - concatEager
        - concat とは違って結合する Flowable は同時に実行される
        - しかし、最終的に通知されるデータはキャッシュされ、個々の Flowable が完了してから通知される
    - startWith
        - 引数に Flowable を受け取る
        - その受け取った Flowable が通知するデータを先に購読者に通知し、そのあとで元の Flowable のデータを通知する
    - zip
        - 複数の Flowable から同じインデックスのデータを全て受け取ったら通知する
        - Flowable 1 がインデックス 0 のデータを通知しても、 Flowable 2 が同じインデックス 0 のデータを通知するまでは、データの通知は待機される
        - Flowable 2 がインデックス 0 のデータを通知したら、初めてデータが通知される
        - 通知されるデータの数が Flowable 間で揃っておらず、どれかが先に完了を通知した場合は、残りの Flowable のデータは無視される
        - オペレータには揃ったインデックスのデータが引数に渡される
        - オペレータが返した新しいデータが、最終的に購読者に通知される
        - 通知タイミングが制御できない複数のタイムラインからのデータの受け取りを制御するのに利用できそう
    - combineLatest
        - 複数の Flowable の通知データをまとめるのは zip と同じ
        - 違うのは、 zip は同じインデックスのデータが全ての Flowable から通知されるのを待機したが、 combineLatest はどれか１つでも Flowable がデータを通知したら、その時点で最後に通知されていたデータをまとめてオペレータに渡す
        - 片方の Flowable からのデータの通知が止まっていても、最後に通知されたデータが繰り返しオペレータに渡される
        - どれかが完了通知をした場合も、最後に通知されたデータが引き続き利用される
- Flowable/Observable の状態を通知するオペレータ
    - isEmpty
        - 空かどうかを判定する
        - データが通知されずに完了が通知されたら true
        - 完了を通知しない場合は使えない
    - contains
        - 指定したデータを含むかどうかを判定する
        - 条件に一致するデータが通知された時点で true を返す
            - 残りのデータは通知されない
            - 完了通知もないっぽい
        - 一致するデータが無いまま完了が通知された場合は false を返す
    - all
        - 全てのデータが条件に一致するか判定する
    - sequenceEqual
        - ２つの Flowable が同じ順序で同じデータを同じ数だけ通知しているかどうか検証する
    - count
        - 通知されるデータ量を通知する
    - reduce
        - 通知されるデータを集計し、集計結果を通知する
        - 第一引数が初期値、第二引数が関数
        - 関数の第一引数が集計の累計
            - 初回が初期値
            - 二回目以降は前回関数が return した値
    - scan
        - reduce は最終結果だけを通知するが、 scan は計算途中も通知する
- ユーティリティ系オペレータ
    - repeat
        - 元の Flowable が通知したものと同じデータを繰り返し通知する
        - 回数を指定しないと無限に通知される
        - 回数を指定すると、指定した回数通知される
    - repeatUntil
        - 引数で boolean を返す関数を渡す
        - 関数が true を返すまで同じデータを繰り返し通知する
        - つまり、 false の間は通知をつづける
    - repeatWhen
        - 引数に関数を渡す
        - 関数には繰り返しを制御するための Flowable が渡される(handler)
        - まず最初に、元の Flowable が通知するデータがそのまま消費者に通知される
        - 以後、 handler がデータを１つ通知するごとに、最初に通知したものと同じ一連のデータが消費者に通知される
        - handler が完了を通知したら、繰り返しが終了する
        - ちょっと分かりづらい・・・
    - delay
        - データを通知し始めるのを指定した時間遅らせる
        - 引数で Flowable を渡して、その Flowable がデータを通知するまで元の通知を遅らせるものもある
    - delaySubscription
        - 処理の開始を遅らせる
        - delay は処理自体はすぐに開始され、通知を遅らせる
    - timeout
        - 次にデータが通知されるまでのタイムアウト時間を指定する
        - 時間を過ぎてもデータが通知されない場合はエラーが通知される
        - タイムアウトした場合は代替データを通知して完了させることも可能

# Processor と Subject
- Processor とは
    - Publisher と Subscriber の両方を継承したインターフェース
    - 生産者と消費者の間に入り通知の橋渡しとなる
    - マルチスレッドで使う場合は注意が必要
        - Reactive Streams のルールで、 onNext() を並行して実行してはいけないことになっている
        - Processor がマルチスレッドで動くと、 onNext() を同時に実行してしまうことになる
        - 通知メソッドがどのように呼ばれているかに注意が必要
            - 通知を同期する SerializedProcessor 用意されている
            - toSerialized() メソッドで変換する
            - 当然同期のコストはかかるようになる
    - FlowableProcessor
        - Processor を実装した抽象クラス
        - Publisher の実装クラスである Flowable を継承している
    - Subject
        - FlowableProcessor と同じような機能を持つつバックプレッシャー機能がないインターフェース
        - Observable と Observer を継承している
- PublishProcessor
    - 購読したデータをそのまま通知する
    - データはキャッシュされないので、既に通知済みのデータは後から購読を開始した消費者には通知されない
    - ただし、完了やエラーは終了後でも通知される
- BehaviorProcessor
    - 最後に通知したデータだけをキャッシュしている Processor
    - 途中から購読を開始した消費者は、最後にキャッシュされたデータから通知される
    - 完了とエラーについては PublishProcessor と同じ
- ReplayProcessor
    - すべて or 指定した範囲で通知したデータをキャッシュする
    - あとで購読を開始した消費者には、購読したタイミングでそれまでにキャッシュされていたデータがすべて通知される
        - その後は普通に通知される
    - 当然のことながら、全てのデータをキャッシュするとメモリを圧迫する
- AsyncProcessor
    - 完了が通知されると、その直前に通知されたデータと完了だけが消費者に通知される
    - 完了が通知されるまでは、途中のデータは一切通知されない
    - エラーが発生した場合はエラーのみが通知される
- UnicastProcessor
    - １つの消費者しか購読できない
    - 消費者を複数登録しようとすると、 IllegalStateException がエラー通知される
        - エラー通知を受け取るのは追加で登録しようとした消費者のみ
        - もとから購読している消費者には何も通知されず、引き続き普通にデータの購読が可能
    - すべてのデータをキャッシュしている
        - あとから購読したら、キャッシュされていたすべてのデータが通知される
        - エラーで終了していても、エラーが発生するまでに通知されていた全てのデータがキャッシュされており、あとから購読した場合はそのキャッシュデータも通知される
            - キャッシュデータが通知され終わったあとで、エラーが通知される

# RxJava のデバッグとテスト
- 一般的に RxJava のテストは難しい
    - 通知データは外部からアクセスできないようにできている
    - 非同期処理の場合は結果が一定にならない可能性がある
- RxJava にはテストをサポートするメソッドが用意されている
    - do で始まるメソッド
        - 各通知が行われるときに実行する処理を設定できる
        - 通知時にログ出力などが可能になる
    - blocking で始まるメソッド
        - Flowable/Observable が別スレッドで実行されても、結果を呼び出し元のスレッドで受け取れるようになる
        - テストを実行しているスレッドで結果を受け取れる
    - TestSubscriber/TestObserver
        - テストを行うための消費者
        - assert メソッドが用意されている
    - TestScheduler
        - 実際に時間を待つのではなく、即座にデータを受け取れるようにするための Scheduler
- これらを使っても、非同期処理については確実にテストできるわけではない点に注意が必要
- do, blocking は普通の処理を書くときにも利用できるが、あくまで元はデバッグが目的という点に注意が必要

## do で始まるメソッド
