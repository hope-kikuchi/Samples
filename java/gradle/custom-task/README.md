https://docs.gradle.org/current/userguide/custom_tasks.html#header

- Gradle でタスクを定義する方法は２種類存在する
    - 普通に `task xxx {}` で定義する方法
        - そのビルドスクリプトでだけ使用するようなタスクを定義するのに適している
        - タスクの振る舞いをクロージャの中で定義する
    - 拡張タスク (enhanced task)
        - タスクの振る舞いは、タスク自身の中に存在する
        - 外部からは、振る舞いを調整するためのプロパティを指定する
        - 複数のビルドタスクで使いまわしやすくなる
- 使用言語
    - JVM で実行できる形になれば、なんでもOK
    - Groovy, Java, Kotlin
    - 静的型付言語のほうがパフォーマンスはいいらしい
- 実装を定義できる場所
    - ビルドスクリプトの中に直接書き込む
        - 作成するのは楽
        - そのスクリプト内でしか利用できない

------
https://docs.gradle.org/current/userguide/more_about_tasks.html

# Task outcomes
- タスクを実行すると、タスクに状態を表すラベルが付与される
    - `(no label) or EXECUTED`
        - タスクは実行すると判断された
    - `UP-TO-DATE`
        - タスクの出力が変化していない
        - タスクは出力を持つが、入力が変化していない
        - タスクが、 Gradle に対して出力が変化しないことを通知した
    - `FROM-CACHE`
        - タスクの出力結果が、以前のキャッシュから見つかった
    - `SKIPPED`
        - タスクは実行されなかった
        - コマンドラインから明示的に除外された
        - `onlyIf` で指定した条件が false を返した
    - `NO-SOURCE`
        - タスクを実行する必要はない
        - 入力に指定されているものがなかった

## Defining tasks
- `task('xxxx')`, `task('xxxx', type: Copy)` というタスク定義は、それぞれ
- `tasks.create('xxxx')`, `tasks.create('xxxx', Copy)` のシンタックスシュガーになっている
    - `tasks` は、 `TaskContainer` のインスタンス

## Locating tasks
- タスクの定義や依存関係を定義するために、タスクを取得（見つけ出す）必要が生まれる
- 動的プロパティの仕組みを利用して、 DSL 的にアクセスする方法
    - タスクを定義すると、 `project` に動的にタスク名のプロパティが追加される
    - 従って、タスク名をそのまま書くことで、直接タスクにアクセスできる
- `tasks` からパスを指定して検索する方法
    - `tasks[':foo:bar']` のように、パスをキーにして取得できる

## Configuring tasks
- `task foo(type: Copy)` のようにすることで、 `Copy` 型のタスクを生成できる
- この方法なら、名前を変えて複数の `Copy` 型のタスクを定義できる
- 前述の方法でタスクを取得すれば、あとは `Copy` が提供するプロパティにプログラミング的に値を設定できる
- しかし、 configuration block を利用した方法のほうが、より可読性の高い設定を記述できる
- configuration block の直下は設定フェーズで実行される点に注意（実行フェーズではない）
    - つまり、タスクが実行されなくても、 configuration block 内は実行される

## Passing arguments to a task constructor
- タスクのコンストラクタ引数に値を渡す方法がある
- コンストラクタを `@javax.inject.Inject` でアノテートする
    - `@Inject` でアノテートできるコンストラクタは１つだけ
- 呼び出し方は、 `task xxx(type: Xxx, constructorArgs: [...])`

## Adding dependencies to a task
- プロジェクト内のタスクであれば、名前を指定して直接タスクを参照できうｒ
- 他のプロジェクトのタスクの場合は、プロジェクト名を含めた完全名で参照が可能
    - `:projectB:taskX`
- `dependsOn` にクロージャを渡す方法もある
    - クロージャは、依存するタスクもしくはコレクションを返すように実装する
    - クロージャはタスクが全て定義されたあとで呼ばれる

## Ordering tasks
- 明示的に依存関係を定義せずにタスクの順序をコントロールできたほうが便利なことがある
- 依存関係の定義による順序づけと、単純な順序付けの違い
    - 単純な順序付けは、２つのタスクが同時に実行されたときの順序しか制御しない
    - 一方を実行したからといって、他方も実行されるわけではない
- タスクの順序付けが有効なケース
    - タスクが順番通りに実行されることを強制する
        - `clean build` と指定したときに、 `build` が先に動かないようにする
    - ビルドの早い段階で検証のタスクを実行する
    - 複数のタスクの結果をまとめるようなタスクを最後に実行させる
- ２つの方法がある
    - `must run after`
        - 指定した順序で必ず実行されるようになる
    - `should run after`
        - 似ているが、ちょっと制限がゆるい
        - タスクの関係が循環した場合、 should で定義した順序は無視される
            - `a -dependsOn-> b -dependsOn-> c -should run after-> a`
            - この場合、 a は c のあとで実行されるべきと定義されているが、そうするとタスクの関係が循環する
            - この場合は c -> a の順序は無視され、 c -> b -> a の順序で実行される
        - 並列実行している場合に動作が違うらしいがよくわからない

## Adding a description to a task
- `description` にタスクの説明を設定できる

## Replacing tasks
- `task xxx(overwrite: true)` でタスクを作成すると、既存の同名のタスクを上書きしてい定義できる
- `overwrite` を指定していない状態で同名のタスクを定義した場合は、例外がスローされる

## Task rules
- `tasks.addRule()` でタスクルールを定義できる
- コマンドラインで指定されたタスクが存在しない場合に、 `addRule()` で指定したブロックがコールされる
- ブロック内には不明となったタスク名が引数で渡されるので、その情報をもとに任意のタスクを動的に定義できる
- あらかじめタスク名を定義できないような柔軟な定義が要求されるタスクに使えるということか
- `addRule()` に渡される不明なタスク名は、 `dependsOn` などで静的に指定されているタスクも対象となる

### 標準で用意されている rule
- `clean<TaskName>` というルールが用意されている
- タスクの出力（outputs）に指定されているファイルやディレクトリを削除するタスクが自動的に定義される

## Finalizer tasks
- `<task1>.finalizedBy <task2>` とすると、 `task1` のあとに必ず `task2` が実行されるようになる
- `task2` は、 `task1` がエラーで失敗しても必ず実行される点に注意
    - ちょうど、 `try-catch` の `finally` のイメージ
- 絶対に実行しなければならない処理などを finalizer として指定する
- ドキュメントでは up-to-date なら実行されないと書いてあるが、実際は実行された

## Lifecycle tasks
- ライフサイクルタスクとは、それ自体は何もしない
- 次のような用途に用いる
    - ワークフローのステップ
        - `check` タスクは、全てのチェック処理を実行する
    - ビルド可能なもの
        - よくわからん
    - 同じような複数のタスクを一括して実行する簡易メソッド
        - `compileAll` が全てのコンパイルタスクを実行する
- 多くの Gradle プラグインは、これらの便利なライフサイクルタスクを定義している
- 自分でプラグインを作るときも、このようなライフサイクルメソッドを作るか、既存の Gradle のライフサイクルタスクにフックするのがいい
    - 例えば、 Java プラグインは Base プラグインで定義されている `clean` や `build` のようなライフサイクルメソッドに依存タスクを追加して、 Java プラグイン関係のタスクが実行されるようにしている
    - `assemble` の依存タスクに `jar` を追加
    - `check` の依存タスクに `test` を追加
- ライフサイクルタスクが up-to-date になるかどうかは、依存タスクが全て up-to-date となるかに依る
    - １つでも executed になった場合は、ライフサイクルタスクも executed になる
    - 全ての依存タスクが up-to-date になった場合は、ライフサイクルタスクも up-to-date になってスキップされる

---
[Build Lifecycle](https://docs.gradle.org/current/userguide/build_lifecycle.html)

- Gradle はタスクの依存関係を定義できる
- たとえ複数のタスクから依存されていたとしても、１回の実行の中で各タスクは一度だけ実行されることが保証されている
- これを実現するため、 Gradle は最初にタスクの依存関係を表すグラフを作成する

## Build phases
- Gradle の実行は３つのフェーズに分かれている
    1. Initialization (初期化フェーズ)
        - 単一プロジェクトかマルチプロジェクトかなどを判定し、 `Project` のインスタンスを生成するフェーズ
    2. Configuration (設定フェーズ)
        - 各プロジェクトのビルドスクリプトが実行され、 `project` オブジェクトの設定が構築されるフェーズ
    3. Execution (実行フェーズ)
        - コマンドラインで指定されたタスクを実行するフェーズ

## Settings file
- ビルドスクリプトの横に `settings.gradle` というファイルを置くことができる
    - 階層型のマルチプロジェクトの場合はルートにだけ配置する
- このファイルは、初期化フェーズで処理される
- マルチプロジェクトかどうかを決定するために必要なので、マルチプロジェクトでは、このファイルは必須
    - 単一プロジェクトの場合は任意
- このファイルの中でアクセスするメソッドやプロパティアクセスは、 `Settings` クラスのインスタンスに委譲される

## Responding to the lifecycle in the build script
- ビルドプロセスのライフサイクルイベントの通知を受け取ることができる
- リスナーインターフェースを実装する方法と、イベントを受け取ったときに実行するクロージャを登録する方法がある
- ここでは、クロージャによる方法だけを説明する
- リスナーインターフェースによる方法は、 API ドキュメントを参照
- プロジェクトが評価される前後にイベントを受け取ることができる
    - ビルドスクリプト全体で共有する情報を定義したり、処理を挟んだりできる
    - `afterEvaluate {...}`
        - プロジェクトが評価されたあとの処理を登録できる
- `gradle.taskGraph.beforeTask { Task -> ...}`
    - タスクが実行される前に呼ばれる
    - クロージャには、実行されるタスクオブジェクトが渡される
    - `afterTask { Task, TaskState -> ...}` はタスクの実行後に呼ばれる

## Incremental tasks
https://docs.gradle.org/current/userguide/custom_tasks.html#incremental_tasks

- 入力と出力の両方が最新の場合、 Gradle はタスクの実行をスキップする
- しかし、次のようなケースでは非効率になることがある
    - あるタスクが、複数のファイルを入力として持つ
    - ある入力ファイルの変更が、別の入力ファイルによる動作に影響を与えない
    - 特定のファイルだけが変更された
- しかし、特定のファイル以外の入力は変わっておらず、またそれらの変わっていない入力ファイルによって実行される結果が変わらない場合、特定のファイルの変更でタスクが全て再実行されるのは効率が悪い
- このようなケースでは、インクリメンタルタスクを定義すると効率よくタスクを実行できるように成る
- インクリメンタルタスクは、アクションメソッドで `IncrementalTaskInputs` を受け取るように定義する
- `IncrementalTaskInputs` は、 `isIncremental()` メソッドでインクリメンタルな実行が可能かどうかを判定できる
    - 特定の入力ファイルだけが変更された場合は、 `true` を返す
    - `@Input` で指定したプロパティの値が変更された場合のように、変更された入力ファイルを特定できないようなケースでは `false` を返す
    - `false` を返した場合は、インクリメンタルビルドはできないので、おとなしく前処理を再実行する
- `true` を返した場合は、インクリメンタルビルドが可能となる
- この場合、 `IncrementalTaskInputs` の `outOfDate()` および `remvoed()` で登録したアクションがコールバックされる
- それぞれのメソッドに登録したアクションには、変更されたファイルの情報を持つ `InputFileDetails` が渡される
    - このクラスの `isAdded()`, `isModified()`, `isRemoved()` で、どういう変更があったかがわかる
    - `getFile()` で、変更のあったファイルを取得できる
- アクションは、変更を検知したファイルの分だけ呼ばれる
- したがって、変更のあったファイルだけに絞ってタスクを実行することができる

## Lazy Configuration
https://docs.gradle.org/current/userguide/lazy_configuration.html

- Gradle は遅延プロパティを提供している
    - 遅延プロパティは、そのプロパティの値が要求されるまで評価が遅延される
    - この機能は、プラグインを作るための３つの便利な機能を提供する
1. 遅延プロパティを利用する側は、プロパティがいつ設定されるかを知る必要がない
    - もしプロパティが他のプラグインによって設定されるような場合でも、具体的にいつ設定されるかを知る必要はない
2. タスク間を、そのタスクの入出力だけでつなげることができる
3. 設定フェーズ中にプロパティを初期化する処理を実行しないようにできる
    - 必要ない処理を減らせる分、パフォーマンスが良くなる
- 遅延プロパティのために２つのインターフェースを提供している
    - Provider
        - 問い合わせのみ可能で変更できない値を表現する
        - `get()` メソッドが、現在の実際の値を返す
        - `map(Transformer)` で、値を変換した新しい `Provider` を生成できる
    - Property
        - 読み書き可能な値を表現する
        - `Provider` のサブインターフェース
        - `set(T)` で値を更新できる
        - `ObjectProperty.property(Class)` で生成できる
- Provider, Property の生成
    - Provider
        - ProviderFactory.provider(Callable) で生成可能
        - ProviderFactory は Project.getProviders() で取得できる
    - Property
        - ObjectFactory の property(Class) メソッド
        - ObjectFactory は Project.getObjects() で取得可能
- ファイル
    - FileCollection と FileTree も、遅延型の一種と考えられる
    - RegularFileProperty, DirectoryProperty が Property のサブタイプとして用意されている
    - いずれも、 ObjectFactory から生成できる
    - DirectoryProperty は、そのディレクトリからの相対パスで別の DirectoryProperty や RegularFileProperty を生成できる
- コレクション
    - ListProperty, SetProperty が用意されている
    - いずれも ObjectFactory から生成できる
    - HasMultipleValues というインターフェースを継承している
        - このインターフェースには、 add() などのメソッドが用意されている
        - つまり、 ListProperty のまま内部のコレクションの状態を更新できるようになっている
        - いちいち get() で中のコレクションを取り出さなくていい
- プロパティを変更不可にする
    - 一度設定値が決定したら、以後はバグ回避のためにも無用な変更を避けたくなることがある
    - finalizeValue() というメソッドが用意されている
    - このメソッドを実行すると、以後そのプロパティは値を変更できなくなる
    - 変更しようとするエラーになる
- タスクに Property 型のフィールドが存在した場合の特別動作
    - Gradle はタスクのフィールドに Property 型のものが存在した場合、自動的に Setter メソッドを生成する
    - たとえば、 foo という Property 型のフィールドが存在した場合、 setFoo(Object) というメソッドが生成される
    - これを利用すると、 foo プロパティに対して代入演算子で値を設定できるようになる
    - `someTask.foo = "zzz"` という感じ
        - この代入演算子は、 setFoo() のシンタックスシュガーになっている